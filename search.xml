<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入浅出 Python 爬虫相关知识</title>
    <url>/2019/12/27/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Python-%E7%88%AC%E8%99%AB%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="爬虫的四个步骤"><a class="header-anchor" href="#爬虫的四个步骤"></a>爬虫的四个步骤</h2>
<ul>
<li>获取数据
<ul>
<li>Requests 库</li>
</ul>
</li>
<li>解析数据
<ul>
<li>BeautifulSoup 库</li>
</ul>
</li>
<li>提取数据</li>
<li>存储数据</li>
</ul>
<h2 id="使用-urllib-request-对-url-parameters-进行转码"><a class="header-anchor" href="#使用-urllib-request-对-url-parameters-进行转码"></a>使用 urllib.request 对 url parameters 进行转码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">string = input(&apos;Hello World&apos;)</span><br><span class="line">encode_string = string.encode(&apos;gbk&apos;)</span><br><span class="line">url = &apos;https://www.baidu.com?keyword=&apos; + urllib.request.quote(encode_string)</span><br></pre></td></tr></table></figure>
<h2 id="使用-requests-获取数据"><a class="header-anchor" href="#使用-requests-获取数据"></a>使用 requests 获取数据</h2>
<p>安装</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 requests</span></span><br><span class="line">pip3 install requests</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引入 requests 库</span></span><br><span class="line">res = requests.get(<span class="string">'URL'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加参数访问</span></span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">'hello'</span>: <span class="string">'world'</span></span><br><span class="line">&#125;</span><br><span class="line">res = requests.get(<span class="string">'URL'</span>, params=payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加请求头</span></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="comment"># 请求来源，本案例中其实是不需要加这个参数的</span></span><br><span class="line">    <span class="string">'origin'</span>:<span class="string">'https://y.qq.com'</span>,</span><br><span class="line">    <span class="comment"># 请求来源，携带的信息比“origin”更丰富</span></span><br><span class="line">    <span class="string">'referer'</span>:<span class="string">'https://y.qq.com/n/yqq/song/004Z8Ihr0JIu5s.html'</span>,</span><br><span class="line">    <span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br><span class="line">res = requests.get(<span class="string">'URL'</span>, params=payload, headers=headers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印变量 res 的数据类型：requests.models.Response 类</span></span><br><span class="line">print(type(res))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动处理 JSON</span></span><br><span class="line">res.json()</span><br></pre></td></tr></table></figure>
<h4 id="request-models-response-类"><a class="header-anchor" href="#request-models-response-类"></a>request.models.Response 类</h4>
<p>常用成员属性：</p>
<ul>
<li>response.status_code - 检查请求是否成功</li>
<li>response.content - 把 response 对象转换为二进制数据</li>
<li>response.text - 把 response 对象转换为字符串数据</li>
<li>response.encoding - 定义 response 对象的编码</li>
</ul>
<h4 id="request-session-会话对象"><a class="header-anchor" href="#request-session-会话对象"></a>request.Session - 会话对象</h4>
<p>会话对象让你能够跨请求保持某些参数。它也会在同一个 Session 实例发出的所有请求之间保持 cookie， 期间使用 urllib3 的 connection pooling 功能。所以如果你向同一主机发送多个请求，底层的 TCP 连接将会被重用，从而带来显著的性能提升。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">session = requests.Session()</span><br><span class="line">session.get(<span class="string">'url'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="requests-cookies-转换存储方法"><a class="header-anchor" href="#requests-cookies-转换存储方法"></a>requests.cookies - 转换存储方法</h4>
<p><img src="https://sebastian-1256190695.cos.ap-guangzhou.myqcloud.com/python/python-cookies-%E8%BD%AC%E6%8D%A2%E5%AD%98%E5%82%A8.png" alt="image"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 cookies 转化成字典</span></span><br><span class="line">cookies_dict = requests.utils.dict_from_cookiejar(session.cookies)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 cookies 字典转化成字符串</span></span><br><span class="line">cookies_str = json.dumps(cookies_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把 cookies 字符串存储起来</span></span><br><span class="line">file = open(<span class="string">'cookies.txt'</span>, <span class="string">'w'</span>)</span><br><span class="line">file.write(cookies_str)</span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure>
<p><img src="https://sebastian-1256190695.cos.ap-guangzhou.myqcloud.com/python/python-cookie-%E8%BD%AC%E6%8D%A2.png" alt="image"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">cookies_txt = open(<span class="string">'cookies.txt'</span>, <span class="string">'r'</span>)</span><br><span class="line">cookies_dict = json.loads(cookies_txt.read())</span><br><span class="line">cookies = requests.utils.cookiejar_from_dict(cookies_dict)</span><br><span class="line">session.cookies = cookies</span><br></pre></td></tr></table></figure>
<h2 id="使用-beautifulsoup-解析数据"><a class="header-anchor" href="#使用-beautifulsoup-解析数据"></a>使用 BeautifulSoup 解析数据</h2>
<p>安装</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装 BeautifulSoup</span></span><br><span class="line">pip3 install BeautifulSoup4</span><br></pre></td></tr></table></figure>
<p>示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">res = requests.get(<span class="string">'https://localprod.pandateacher.com/python-manuscript/crawler-html/spider-men5.0.html'</span>) </span><br><span class="line">html = res.text</span><br><span class="line"></span><br><span class="line"><span class="comment">#把网页解析为BeautifulSoup对象</span></span><br><span class="line">soup = BeautifulSoup(html,<span class="string">'html.parser'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="beautifulsoup-对象常用方法与属性"><a class="header-anchor" href="#beautifulsoup-对象常用方法与属性"></a>BeautifulSoup 对象常用方法与属性</h4>
<ul>
<li>方法
<ul>
<li>find(tag, attributes, recursive, text, keywords)
<ul>
<li>作用：提取满足要求的首个数据</li>
<li>用法：BeautifulSoup 对象.find(‘标签’, ‘属性’)</li>
<li>示例：<code>soup.find('div', class_='books')</code></li>
<li>返回：Tag 类对象</li>
</ul>
</li>
<li>find_all(tag, attributes, recursive, text, limit, keywords)
<ul>
<li>作用：提取满足要求的所有数据</li>
<li>用法：BeautifulSoup 对象.find(‘标签’, ‘属性’)</li>
<li>示例：<code>soup.find_all('div', style_='books')</code></li>
<li>返回：ResultSet 类对象，本质是 Tag 类对象的列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>示例</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests </span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">res = requests.get(<span class="string">'https://localprod.pandateacher.com/python-manuscript/crawler-html/spider-men5.0.html'</span>)</span><br><span class="line">html= res.text</span><br><span class="line"></span><br><span class="line">soup = BeautifulSoup( html,<span class="string">'html.parser'</span>)</span><br><span class="line">items = soup.find_all(class_=<span class="string">'books'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">    print(<span class="string">'想找的数据都包含在这里了：\n'</span>,item)</span><br></pre></td></tr></table></figure>
<h4 id="tag-对象常用方法与属性"><a class="header-anchor" href="#tag-对象常用方法与属性"></a>Tag 对象常用方法与属性</h4>
<ul>
<li>Tag.find()、Tag.find_all()：提取 Tag 中的 Tag。</li>
<li>Tag.text：提取 Tag 中的文字。</li>
<li>Tag[‘属性名’]：输入参数属性名，可以提取 Tag 这个属性的值。</li>
</ul>
<h4 id="编写爬虫通用业务流程"><a class="header-anchor" href="#编写爬虫通用业务流程"></a>编写爬虫通用业务流程</h4>
<p><img src="https://sebastian-1256190695.cos.ap-guangzhou.myqcloud.com/python/python-%E7%88%AC%E8%99%AB%E9%80%9A%E7%94%A8%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<h2 id="使用-selenium-操控浏览器"><a class="header-anchor" href="#使用-selenium-操控浏览器"></a>使用 Selenium 操控浏览器</h2>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install selenium</span><br></pre></td></tr></table></figure>
<p>本地 Google Chrome 设置方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"># 设置 Chrome 驱动</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"></span><br><span class="line"># 打开网址</span><br><span class="line">driver.get(&apos;https://localprod.pandateacher.com/python-manuscript/hello-spiderman/&apos;)</span><br><span class="line"></span><br><span class="line"># 等待页面加载</span><br><span class="line">time.sleep(2)</span><br><span class="line"></span><br><span class="line"># 关闭页面</span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>
<h4 id="selenium-提取-html-元素"><a class="header-anchor" href="#selenium-提取-html-元素"></a>Selenium 提取 HTML 元素</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>find_element_by_tag_name、find_elements_by_tag_name</td>
<td>通过元素的标签名称选择</td>
</tr>
<tr>
<td>find_element_by_class_name、find_elements_by_class_name</td>
<td>通过元素的 class 属性选择</td>
</tr>
<tr>
<td>find_element_by_id、find_elements_by_id</td>
<td>通过元素的 id 选择</td>
</tr>
<tr>
<td>find_element_by_name、find_elements_by_name</td>
<td>通过元素的 name 属性选择</td>
</tr>
<tr>
<td>find_element_by_link_text、find_elements_by_link_text</td>
<td>通过链接文本获取超链接</td>
</tr>
<tr>
<td>find_element_by_partial_link_text、find_elements_by_partial_link_text</td>
<td>通过链接的部分文本获取超链接</td>
</tr>
</tbody>
</table>
<h4 id="selenium-操作浏览器"><a class="header-anchor" href="#selenium-操作浏览器"></a>Selenium 操作浏览器</h4>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟按键输入，自动填写表单</span></span><br><span class="line">WebElement.send_keys(<span class="string">'123456'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击元素</span></span><br><span class="line">WebElement.click()</span><br></pre></td></tr></table></figure>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下方法都可以从网页中提取出'你好，蜘蛛侠！'这段文字</span></span><br><span class="line"></span><br><span class="line">find_element_by_tag_name：通过元素的名称选择</span><br><span class="line"><span class="comment"># 如&lt;h1&gt;你好，蜘蛛侠！&lt;/h1&gt; </span></span><br><span class="line"><span class="comment"># 可以使用find_element_by_tag_name('h1')</span></span><br><span class="line"></span><br><span class="line">find_element_by_class_name：通过元素的<span class="class"><span class="keyword">class</span>属性选择</span></span><br><span class="line"># 如&lt;h1 class="title"&gt;你好，蜘蛛侠！&lt;/h1&gt;</span><br><span class="line"><span class="comment"># 可以使用find_element_by_class_name('title')</span></span><br><span class="line"></span><br><span class="line">find_element_by_id：通过元素的id选择</span><br><span class="line"><span class="comment"># 如&lt;h1 id="title"&gt;你好，蜘蛛侠！&lt;/h1&gt; </span></span><br><span class="line"><span class="comment"># 可以使用find_element_by_id('title')</span></span><br><span class="line"></span><br><span class="line">find_element_by_name：通过元素的name属性选择</span><br><span class="line"><span class="comment"># 如&lt;h1 name="hello"&gt;你好，蜘蛛侠！&lt;/h1&gt; </span></span><br><span class="line"><span class="comment"># 可以使用find_element_by_name('hello')</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以下两个方法可以提取出超链接</span></span><br><span class="line"></span><br><span class="line">find_element_by_link_text：通过链接文本获取超链接</span><br><span class="line"><span class="comment"># 如&lt;a href="spidermen.html"&gt;你好，蜘蛛侠！&lt;/a&gt;</span></span><br><span class="line"><span class="comment"># 可以使用find_element_by_link_text('你好，蜘蛛侠！')</span></span><br><span class="line"></span><br><span class="line">find_element_by_partial_link_text：通过链接的部分文本获取超链接</span><br><span class="line"><span class="comment"># 如&lt;a href="https://localprod.pandateacher.com/python-manuscript/hello-spiderman/"&gt;你好，蜘蛛侠！&lt;/a&gt;</span></span><br><span class="line"><span class="comment"># 可以使用find_element_by_partial_link_text('你好')</span></span><br></pre></td></tr></table></figure>
<h4 id="webelement-对象常用方法与属性"><a class="header-anchor" href="#webelement-对象常用方法与属性"></a>WebElement 对象常用方法与属性</h4>
<ul>
<li>WebElement.text - 提取文字</li>
<li>WebElement.get_attribute() - 输入参数</li>
</ul>
<h2 id="反爬策略"><a class="header-anchor" href="#反爬策略"></a>反爬策略</h2>
<ul>
<li>豆瓣电影 Top250 使用 HTTP 头部进行验证
<ul>
<li>模拟正常行为头部，添加至每次请求当中</li>
</ul>
</li>
<li>QQ 音乐、搜索「周杰伦」使用 Ajax 进行反爬
<ul>
<li>查看所有 XHR，优先查看传输时间长，传输体积大的请求</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 的基础使用</title>
    <url>/2019/12/21/Python-%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="python-字符串"><a class="header-anchor" href="#python-字符串"></a>Python 字符串</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 三引号 - 直接换行</span><br><span class="line">print(&quot;&quot;&quot;\</span><br><span class="line">千寻你好，人们叫我&apos;无脸男&apos;</span><br><span class="line">这个世界的人都选择无视我</span><br><span class="line">只有你看到了我并和我打招呼</span><br><span class="line">我感到很孤单，很孤单</span><br><span class="line">你愿意和我成为朋友吗？&quot;&quot;&quot;)</span><br><span class="line"></span><br><span class="line"># 双引号 - 转义换行</span><br><span class="line">print(&quot;\n千寻你好，人们叫我&apos;无脸男&apos;\n这个世界的人都选择无视我\n只有你看到了我并和我打招呼\n我感到很孤单，很孤单\n你愿意和我成为朋友吗？&quot;)</span><br><span class="line"></span><br><span class="line"># 单引号 - 转义换行，转义单引号</span><br><span class="line">print(&apos;\n千寻你好，人们叫我\&apos;无脸男\&apos;\n这个世界的人都选择无视我\n只有你看到了我并和我打招呼\n我感到很孤单，很孤单\n你愿意和我成为朋友吗？&apos;)</span><br><span class="line"></span><br><span class="line"># %s - 字符串</span><br><span class="line">print(&apos;%s&apos; % str)</span><br><span class="line"></span><br><span class="line"># %f - 浮点数</span><br><span class="line">print(&apos;%f&apos; % float)</span><br><span class="line"></span><br><span class="line"># %d - 整数型</span><br><span class="line">print(&apos;%d&apos; % int)</span><br><span class="line"></span><br><span class="line"># 示例</span><br><span class="line">print(&apos;%s%d&apos;%(&apos;数字：&apos;,0))</span><br></pre></td></tr></table></figure>
<h2 id="python-列表字典"><a class="header-anchor" href="#python-列表字典"></a>Python 列表字典</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">students = [&apos;小明&apos;, &apos;小红&apos;, &apos;小刚&apos;]</span><br><span class="line"></span><br><span class="line"># 从列表中提取单个元素：&quot;小刚&quot;</span><br><span class="line">students[2]</span><br><span class="line"></span><br><span class="line"># 从列表中提取多个元素：[&apos;小明&apos;, &apos;小红&apos;]</span><br><span class="line">students[:2]</span><br><span class="line"></span><br><span class="line"># 给列表增加/删除元素：</span><br><span class="line">students.append(&apos;小美&apos;)</span><br><span class="line">del students[1]</span><br><span class="line"></span><br><span class="line"># 用于移除列表中一个元素，默认取最后一个元素</span><br><span class="line">students.pop()</span><br><span class="line">students.pop(0)</span><br><span class="line"></span><br><span class="line"># 字典</span><br><span class="line">scores = &#123;&apos;小明&apos;: 95, &apos;小红&apos;: 90, &apos;小刚&apos;: 90&#125;</span><br><span class="line"></span><br><span class="line"># 从字典中提取元素</span><br><span class="line">scores[&apos;小明&apos;]</span><br><span class="line"></span><br><span class="line"># 从字典中增加/删除</span><br><span class="line">scores[&apos;小美&apos;] = 85</span><br><span class="line">del scores[&apos;小明&apos;]</span><br></pre></td></tr></table></figure>
<h2 id="python-面向对象"><a class="header-anchor" href="#python-面向对象"></a>Python 面向对象</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 类的继承</span><br><span class="line">class Chinese:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Cantonese(Chinese):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">chinese = Chinese()</span><br><span class="line">cantonese = Cantonese()</span><br><span class="line"></span><br><span class="line">print(&apos;\n验证1：子类创建的实例同时也属于父类&apos;)</span><br><span class="line">print(isinstance(chinese, Chinese))</span><br><span class="line">print(isinstance(cantonese, Chinese))</span><br><span class="line"></span><br><span class="line">print(&apos;\n验证2：父类创建的实例不属于子类。&apos;)</span><br><span class="line">print(isinstance(chinese, Cantonese))</span><br><span class="line"></span><br><span class="line">print(&apos;\n验证3：类创建的实例都属于根类。&apos;)</span><br><span class="line">print(isinstance(chinese, object))</span><br><span class="line">print(isinstance(cantonese, object))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 多层继承</span><br><span class="line">class EarthMan:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 中国人继承了地球人</span><br><span class="line">class Chinese(EarthMan):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = &apos;中国人&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 广东人继承了中国人，同时也继承了地球人。</span><br><span class="line">class Cantonese(Chinese):</span><br><span class="line">     def __init__(self, name, type = &apos;foo&apos;):</span><br><span class="line">        Chinese.__init__(self, name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 多重继承：多重继承中，若某父类还有父类的话，会先继续往上找到顶</span><br><span class="line">class Su:</span><br><span class="line">    born_city = &apos;JiangSu&apos;</span><br><span class="line">    wearing = &apos;thick&apos;</span><br><span class="line"></span><br><span class="line">    def diet(self):</span><br><span class="line">        print(&apos;我们爱吃甜。&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Yue:</span><br><span class="line">    settle_city = &apos;GuangDong&apos;</span><br><span class="line">    wearing = &apos;thin&apos;</span><br><span class="line"></span><br><span class="line">    def diet(self):</span><br><span class="line">        print(&apos;我们吃得清淡。&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Yuesu(Yue, Su):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaoming = Yuesu()</span><br><span class="line"># 先在 Yue类找，找到了，打印出来。</span><br><span class="line"></span><br><span class="line">print(xiaoming.wearing)</span><br><span class="line"># Yue类没有born_city，才去Su类找。</span><br><span class="line"></span><br><span class="line">print(xiaoming.born_city)</span><br><span class="line"># 方法调用，和属性调用一样，也符合就近原则。</span><br><span class="line"></span><br><span class="line">xiaoming.diet()</span><br></pre></td></tr></table></figure>
<h2 id="python-文件操作"><a class="header-anchor" href="#python-文件操作"></a>Python 文件操作</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读文件：开 - 读 - 关</span></span><br><span class="line">file1 = open(<span class="string">'/test.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">fileContent = file1.read()</span><br><span class="line">file1.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写文件：开 - 写 - 关</span></span><br><span class="line">file1 = open(<span class="string">'/test.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">fileContent = file1.read()</span><br><span class="line">file1.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取信息</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>, <span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 这时，lines 的数据存放在内存里。</span></span><br><span class="line">    lines = f.readlines()  </span><br><span class="line">    </span><br><span class="line"><span class="comment"># 将读取到的内容打印出来，发现实际上读到的是带换行符的字符串。</span></span><br><span class="line">print(lines)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'test.txt'</span>,<span class="string">'w'</span>) <span class="keyword">as</span> new:</span><br><span class="line">    <span class="comment"># 在内存中，对数据进行处理，然后再写到文档里，覆盖之前的内容。</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:  </span><br><span class="line">        <span class="comment"># 注意：这里的条件要根据上面打印出的数据写。</span></span><br><span class="line">        <span class="keyword">if</span> line <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">'0\n'</span>,<span class="string">'1\n'</span>]:  </span><br><span class="line">            new.write(line)</span><br></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/12065/WEBRESOURCE3693b379d6eb0183fb97f2a2ac272ce3" alt="截屏2019-12-06下午11.36.01.png"></p>
<h2 id="python-csv-读写"><a class="header-anchor" href="#python-csv-读写"></a>Python CSV 读写</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="comment">#引用csv模块。</span></span><br><span class="line"></span><br><span class="line">csv_file = open(<span class="string">'demo.csv'</span>,<span class="string">'w'</span>,newline=<span class="string">''</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="comment">#调用open()函数打开csv文件，传入参数：文件名“demo.csv”、写入模式“w”、newline=''、encoding='utf-8'。</span></span><br><span class="line"></span><br><span class="line">writer = csv.writer(csv_file)</span><br><span class="line"><span class="comment"># 用csv.writer()函数创建一个writer对象。</span></span><br><span class="line"></span><br><span class="line">writer.writerow([<span class="string">'电影'</span>,<span class="string">'豆瓣评分'</span>])</span><br><span class="line"><span class="comment">#调用writer对象的writerow()方法，可以在csv文件里写入一行文字 “电影”和“豆瓣评分”。</span></span><br><span class="line"></span><br><span class="line">writer.writerow([<span class="string">'银河护卫队'</span>,<span class="string">'8.0'</span>])</span><br><span class="line"><span class="comment">#在csv文件里写入一行文字 “银河护卫队”和“8.0”。</span></span><br><span class="line"></span><br><span class="line">writer.writerow([<span class="string">'复仇者联盟'</span>,<span class="string">'8.1'</span>])</span><br><span class="line"><span class="comment">#在csv文件里写入一行文字 “复仇者联盟”和“8.1”。</span></span><br><span class="line"></span><br><span class="line">csv_file.close()</span><br><span class="line"><span class="comment">#写入完成后，关闭文件就大功告成啦！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">csv_file = open(<span class="string">'demo.csv'</span>,<span class="string">'r'</span>,newline=<span class="string">''</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">reader = csv.reader(csv_file)</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">    print(row)</span><br></pre></td></tr></table></figure>
<h2 id="python-excel-读写"><a class="header-anchor" href="#python-excel-读写"></a>Python Excel 读写</h2>
<h4 id="excel-相关概念"><a class="header-anchor" href="#excel-相关概念"></a>Excel 相关概念</h4>
<p>一个Excel文档也称为一个工作薄（workbook），每个工作薄里可以有多个工作表（worksheet），当前打开的工作表又叫活动表。每个工作表里有行和列，特定的行与列相交的方格称为单元格（cell）。比如上图第A列和第1行相交的方格我们可以直接表示为A1单元格。</p>
<h4 id="使用-openpyxl-库读写-excel"><a class="header-anchor" href="#使用-openpyxl-库读写-excel"></a>使用 openpyxl 库读写 Excel</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip3 install openpyxl</span><br></pre></td></tr></table></figure>
<p>使用 openpyxl 库写 Excel 示例<br>
<img src="http://note.youdao.com/yws/res/12205/WEBRESOURCE05bdb5f6128fd04b2c67d080b122d015" alt="截屏2019-12-15下午8.51.17.png"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 引用openpyxl</span></span><br><span class="line"><span class="keyword">import</span> openpyxl </span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用openpyxl.Workbook()函数创建新的workbook（工作薄）对象，就是创建新的空的Excel文件</span></span><br><span class="line">wb = openpyxl.Workbook()</span><br><span class="line"></span><br><span class="line"><span class="comment"># wb.active就是获取这个工作薄的活动表，通常就是第一个工作表</span></span><br><span class="line">sheet = wb.active</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以用.title给工作表重命名。现在第一个工作表的名称就会由原来默认的“sheet1”改为"new title"</span></span><br><span class="line">sheet.title = <span class="string">'new title'</span></span><br><span class="line">sheet[<span class="string">'A1'</span>] = <span class="string">'漫威宇宙'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 先把要写入的多行内容写成列表，再放进大列表里，赋值给rows</span></span><br><span class="line">rows = [[<span class="string">'美国队长'</span>,<span class="string">'钢铁侠'</span>,<span class="string">'蜘蛛侠'</span>],[<span class="string">'是'</span>,<span class="string">'漫威'</span>,<span class="string">'宇宙'</span>, <span class="string">'经典'</span>,<span class="string">'人物'</span>]]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rows:</span><br><span class="line">    sheet.append(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存新建的Excel文件，并命名为“Marvel.xlsx”</span></span><br><span class="line">wb.save(<span class="string">'Marvel.xlsx'</span>)</span><br></pre></td></tr></table></figure>
<p>使用 openpyxl 库读 Excel 示例<br>
<img src="http://note.youdao.com/yws/res/12207/WEBRESOURCE499d38841721e6700d40bb4851ad71f0" alt="截屏2019-12-15下午8.51.24.png"></p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#读取的代码：</span></span><br><span class="line">wb = openpyxl.load_workbook(<span class="string">'Marvel.xlsx'</span>)</span><br><span class="line">sheet = wb[<span class="string">'new title'</span>]</span><br><span class="line">sheetname = wb.sheetnames</span><br><span class="line">print(sheetname)</span><br><span class="line">A1_cell = sheet[<span class="string">'A1'</span>]</span><br><span class="line">A1_value = A1_cell.value</span><br><span class="line">print(A1_value)</span><br></pre></td></tr></table></figure>
<h2 id="python-运算符"><a class="header-anchor" href="#python-运算符"></a>Python 运算符</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(2+1) # 加法</span><br><span class="line"># 3</span><br><span class="line"></span><br><span class="line">print(1-2) # 减法</span><br><span class="line"># -1</span><br><span class="line"></span><br><span class="line">print(1*2) # 乘法</span><br><span class="line"># 2</span><br><span class="line"></span><br><span class="line">print(1/2) # 除法</span><br><span class="line"># 0.5</span><br><span class="line"></span><br><span class="line">print(2**3) # 幂（2 的 3 次方）</span><br><span class="line"># 8</span><br><span class="line"></span><br><span class="line">print(10%3) # 取模（做除法返回余数）</span><br><span class="line"># 1</span><br><span class="line"></span><br><span class="line">print(10//3) # 取整数（做除法返回商的整数部分）</span><br><span class="line"># 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 布尔运算符</span><br><span class="line"># and 要求条件都满足才为 True</span><br><span class="line"># or 要求其中一个条件满足就为 True</span><br><span class="line">a = 1</span><br><span class="line">b = -1</span><br><span class="line">print(a == 1 and b == 1)</span><br><span class="line">print(a == 1 or b== 1)</span><br><span class="line"></span><br><span class="line"># not 反转真假</span><br><span class="line">a = True</span><br><span class="line">print(not a) # 判断为假</span><br></pre></td></tr></table></figure>
<h2 id="python-异常捕获"><a class="header-anchor" href="#python-异常捕获"></a>Python 异常捕获</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num = [1,2,0,3,1.5,&apos;6&apos;]</span><br><span class="line">for x in num:</span><br><span class="line">    try:  # 尝试执行下列代码</span><br><span class="line">        print (6/x)</span><br><span class="line">    except ZeroDivisionError:</span><br><span class="line">        print(&apos;0是不能做除数的！&apos;)</span><br><span class="line">    except TypeError:  # 当报错信息为TypeError，执行下面的语句。</span><br><span class="line">        print(&apos;被除数必须是整值或浮点数！&apos;)</span><br><span class="line">        </span><br><span class="line">    try: </span><br><span class="line">        print(6/x)</span><br><span class="line">    except (ZeroDivisionError, TypeError):</span><br><span class="line">        print(&apos;Something Wrong.&apos;)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    try:</span><br><span class="line">        print(6/x)</span><br><span class="line">    except Exception:</span><br><span class="line">        print(&apos;Something Wrong.&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="python-常用函数"><a class="header-anchor" href="#python-常用函数"></a>Python 常用函数</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 自定义函数</span><br><span class="line">def $name($params):</span><br><span class="line">    $body</span><br><span class="line">    return $result</span><br><span class="line"></span><br><span class="line">range(a, b, c)</span><br><span class="line"></span><br><span class="line"># 计数从 a 开始，不填时，默认从 0 开始</span><br><span class="line">range(a, 5)</span><br><span class="line"></span><br><span class="line"># 计数到 b 结束，但不包括 b</span><br><span class="line">range(b)</span><br><span class="line"></span><br><span class="line"># 计数的间隔，默认为 1 </span><br><span class="line">range(0, 30, 5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str.format()</span><br><span class="line"></span><br><span class="line"># 优势1：不用担心用错类型码。</span><br><span class="line">print(&apos;\n&#123;&#125;&#123;&#125;&apos;.format(&apos;数字：&apos;,0))  </span><br><span class="line"></span><br><span class="line"># 不设置指定位置时，默认按顺序对应。</span><br><span class="line">print(&apos;&#123;&#125;，&#123;&#125;&apos;.format(0,1))  </span><br><span class="line"></span><br><span class="line"># 优势2：当设置指定位置时，按指定的对应。</span><br><span class="line">print(&apos;&#123;1&#125;，&#123;0&#125;&apos;.format(0,1))  </span><br><span class="line"></span><br><span class="line"># 优势3：可多次调用format后的数据。</span><br><span class="line">print(&apos;&#123;0&#125;，&#123;1&#125;，&#123;0&#125;&apos;.format(0,1))  </span><br><span class="line"></span><br><span class="line">numberList.index()</span><br><span class="line"></span><br><span class="line">num = [0,1,0,1,2]</span><br><span class="line"># 数字1首先出现的索引位置是list[1]（索引位置从0开始）。</span><br><span class="line">print(num.index(1))  </span><br><span class="line"></span><br><span class="line"># 数字2首先出现的索引位置是list[4]。</span><br><span class="line">print(num.index(2))</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Python 发送邮件</title>
    <url>/2019/11/14/%E4%BD%BF%E7%94%A8-Python-%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="内置模块"><a class="header-anchor" href="#内置模块"></a>内置模块</h2>
<ul>
<li>email：构建邮件内容</li>
<li>smtplib：发送邮件</li>
</ul>
<h2 id="stmplib-模块使用示例"><a class="header-anchor" href="#stmplib-模块使用示例"></a>stmplib 模块使用示例</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"><span class="comment"># SMTP Simple Mail Transfer Protocol</span></span><br><span class="line">server = smtplib.SMTP(host, port)</span><br><span class="line"><span class="comment"># SSL 加密</span></span><br><span class="line">server = smtplib.SMTP_SSL(host, port) </span><br><span class="line"><span class="comment"># Python 3.7 以后使用</span></span><br><span class="line">server = smtplib.SMTP_SSL(host, port) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接一个服务器</span></span><br><span class="line">server.connect(host, port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮箱账号与授权码</span></span><br><span class="line">server.login(username, password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送地址，收件人，内容</span></span><br><span class="line">server.sendmail(from_addr, to_addr, msg.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure>
<h2 id="email-模块使用示例"><a class="header-anchor" href="#email-模块使用示例"></a>email 模块使用示例</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文本内容，文本类型，charset</span></span><br><span class="line">msg = MIMEText.(msg, type, charset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 HTML 文档</span></span><br><span class="line">msg = MIMEText.(msg, <span class="string">'html'</span>, <span class="string">'utf-8'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="email-模块配置邮件头部"><a class="header-anchor" href="#email-模块配置邮件头部"></a>email 模块配置邮件头部</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"></span><br><span class="line"><span class="comment"># 邮件标题</span></span><br><span class="line">message[<span class="string">'Subject'</span>] = Header(Subject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发件人</span></span><br><span class="line">message[<span class="string">'From'</span>] = Header(from_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收件人</span></span><br><span class="line">message[<span class="string">'To'</span>] = Header(to_addr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抄送谁</span></span><br><span class="line">message[<span class="string">'Cc'</span>] = Header(<span class="string">','</span>.join(receivers))</span><br></pre></td></tr></table></figure>
<h2 id="email-实现群发"><a class="header-anchor" href="#email-实现群发"></a>email 实现群发</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">receivers = [<span class="string">'email@baidu.com'</span>, <span class="string">'email@google.com'</span>]</span><br><span class="line">server.sendmail(config.from_addr, receivers, content.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure>
<h2 id="email-发送代码简单示例"><a class="header-anchor" href="#email-发送代码简单示例"></a>email 发送代码简单示例</h2>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> config</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接服务器</span></span><br><span class="line">server = smtplib.SMTP_SSL(config.host, config.port)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录服务器</span></span><br><span class="line">server.login(config.username, config.password)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写邮件内容</span></span><br><span class="line">content = <span class="string">'Hello World'</span></span><br><span class="line">content_type = <span class="string">'plain'</span></span><br><span class="line">charset = <span class="string">'utf-8'</span></span><br><span class="line">content = MIMEText(content, content_type, charset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编写邮件头部</span></span><br><span class="line">content[<span class="string">'From'</span>] = config.from_addr</span><br><span class="line">content[<span class="string">'To'</span>] = config.to_addr</span><br><span class="line">content[<span class="string">'Subject'</span>] = Header(config.subject, charset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送邮件</span></span><br><span class="line">server.sendmail(config.from_addr, config.to_addr, content.as_string())</span><br><span class="line">server.quit()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出计算机编码</title>
    <url>/2019/11/12/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h2 id="什么是编码"><a class="header-anchor" href="#什么是编码"></a>什么是编码</h2>
<p>编码的本质就是让只认识 0 和 1 的计算机，能够理解我们人类使用的语言符号，并且将数据转换为二进制进行存储和传输。</p>
<h2 id="为什么计算机只认识-0-和-1"><a class="header-anchor" href="#为什么计算机只认识-0-和-1"></a>为什么计算机只认识 0 和 1</h2>
<p>电子计算机主要是采用数字集成电路搭建的，数字集成电路的基本单元是逻辑门，通过控制高电平和低电平（相当于 1 和 0），从而实现逻辑运算。</p>
<h2 id="什么是二进制"><a class="header-anchor" href="#什么是二进制"></a>什么是二进制</h2>
<p>二进制是计算技术中广泛采用的一种数制。二进制数据是用 0 和 1 两个数码来表示的数。</p>
<h2 id="为什么将数据转换为二进制进行存储和传输"><a class="header-anchor" href="#为什么将数据转换为二进制进行存储和传输"></a>为什么将数据转换为二进制进行存储和传输</h2>
<p>因为数字计算机是由逻辑门组成，而逻辑电路最基础的状态就是两个「开」和「关」。所以，数字电路是以二进制逻辑代数为数学基础。二进制的基本运算规则简单，运算操作方便，这样一来有利于简化计算机内部结构，提高运算速度。而且在逻辑代数方面，二进制只有 0 和 1 两个数码，正好与逻辑代数中的「真」和「假」相吻合。</p>
<h2 id="什么是编码表"><a class="header-anchor" href="#什么是编码表"></a>什么是编码表</h2>
<p>人类语言到计算机语言转换的形式，就叫做编码表，它让人类语言和计算机语言能够一一对应起来。<br>
常用的编码表如下所示：</p>
<table>
<thead>
<tr>
<th>编码表</th>
<th>适用性</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASCII 码</td>
<td>英文大小写，字符，不支持中文</td>
<td>最早的编码，占用空间小</td>
</tr>
<tr>
<td>GB2312 码、GBK 码</td>
<td>支持了中文</td>
<td>GBK 是 GB2312 的升级</td>
</tr>
<tr>
<td>Unicode 码</td>
<td>支持国际语言</td>
<td>占用空间大，适用性强</td>
</tr>
<tr>
<td>UTF-8 码</td>
<td>支持国际语言</td>
<td>Unicode 码升级版，两者之间容易转换。ASCII 码被 UTF-8 码包含</td>
</tr>
</tbody>
</table>
<h2 id="什么是位"><a class="header-anchor" href="#什么是位"></a>什么是位</h2>
<p>位的英文名是 bit，是电子计算机中最小的数据单位，每一个位（bit）的状态只能是 0 或 1。</p>
<h2 id="位-二进制-十六进制的关系"><a class="header-anchor" href="#位-二进制-十六进制的关系"></a>位、二进制、十六进制的关系</h2>
<p>位与二进制：</p>
<ul>
<li>1 位（bit）= 1 个二进制位</li>
<li>1 字节（Byte） = 8 位（bit）</li>
<li>1 字节（Byte） = 8 个二进制位</li>
<li>8 个二进制位 = 00000000 - 11111111 = 十进制位 0 ~ 255</li>
</ul>
<p>位、二进制与十六进制</p>
<ul>
<li>1 个十六进制位 = 0 ~ F  = 0 ~ 15</li>
<li>4 个二进制位 = 0000 ~ 1111 = 0 ~ 15</li>
<li>4 个二进制位 = 1 个十六进制位</li>
<li>1 个字节（Byte）= 8 位（bit）= 8 个二进制位 = 2 个十六进制位 = 0 ~ 255</li>
</ul>
<h1 id="二进制位与十进制位相互转换"><a class="header-anchor" href="#二进制位与十进制位相互转换"></a>二进制位与十进制位相互转换</h1>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 二进制位转换成为十进制位</span><br><span class="line">00000001 = (0 x 128) + (0 x 64) + (0 x 32) + (0 x 16) + (0 x 8) + (0 x 4) + (0 x 2) + (1 x 1) = 1</span><br><span class="line">10000111 = (1 x 128) + (0 x 64) + (0 x 32) + (0 x 16) + (0 x 8) + (1 x 4) + (1 x 2) + (1 x 1) = 135</span><br><span class="line"></span><br><span class="line"># 十进制位与二进制位相互转换</span><br><span class="line">135 / 2 = 67（余数为 1）</span><br><span class="line">67  / 2 = 33（余数为 1）</span><br><span class="line">33  / 2 = 16（余数为 1）</span><br><span class="line">16  / 2 = 8 （余数为 0）</span><br><span class="line">8   / 2 = 4 （余数为 0）</span><br><span class="line">4   / 2 = 2 （余数为 0）</span><br><span class="line">2   / 2 = 1 （余数为 0）</span><br><span class="line">1   / 2 = 0 （余数为 1）</span><br><span class="line"></span><br><span class="line">10000111</span><br></pre></td></tr></table></figure>
<h2 id="十六进制与十进制互相转换"><a class="header-anchor" href="#十六进制与十进制互相转换"></a>十六进制与十进制互相转换</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 十六进制转换成十进制：2AF5</span><br><span class="line">5 * 16^0 = 5</span><br><span class="line">F * 16^1 = 240</span><br><span class="line">A * 16^2 = 2560</span><br><span class="line">2 * 16^3 = 8192</span><br><span class="line">5 * 16^0 + F * 16^1 + A * 16^2 + 2 * 16^3 = 10997</span><br></pre></td></tr></table></figure>
<h2 id="二进制与编码表"><a class="header-anchor" href="#二进制与编码表"></a>二进制与编码表</h2>
<p>世界上存在多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。ASCII 编码表只规定了 128 个字符，仅仅表示中文就不够用了。伴随互联网的普及，强烈要求出现一种统一的编码方式。UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。</p>
<h2 id="utf-8-编码规则"><a class="header-anchor" href="#utf-8-编码规则"></a>UTF-8 编码规则</h2>
<p>Unicode 是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码如何存储。UTF-8 是 Unicode 的实现方式之一。是一种可变的编码方式，可以使用 1 ~ 4 个字节表示一个字符。</p>
<ul>
<li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</li>
<li>对于 n 字节的符号（n &gt; 1），第一个字节的前 n 位都设为 1，第 n + 1 位设为 0，后面字节的前两位一律设为 10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</li>
</ul>
<table>
<thead>
<tr>
<th>Unicode 符号范围</th>
<th>UTF-8 编码方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>十六进制</td>
<td>二进制</td>
</tr>
<tr>
<td>0000 0000-0000 007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080-0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800-0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000-0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody>
</table>
<p>以<code>卢</code>字为例，<code>卢</code>的 Unicode 是 <code>5362</code>，转换成为二进制是 <code>101 0011 0110 0010</code>，根据上表，<code>5362</code> 处于第三行范围内（<code>0000 0800-0000 FFFF</code>），然后，从<code>卢</code>的最后一个二进制位开始，依次从后向前填入格式中的 <code>x</code>，多出的位补 <code>0</code>。这样就得到了，<code>卢</code>的 UTF-8 编码是<code>11100101 10001101 10100010</code>，转换成十六进制就是 <code>E58DA2</code>。运算过程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># UTF-8 编码出现的二进制位</span><br><span class="line">1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">     101   001101   100010</span><br><span class="line">11100101 10001101 10100010</span><br><span class="line"></span><br><span class="line"># 二进制位转十六进制位</span><br><span class="line">11100101 10001101 10100010 =  E58DA2 </span><br><span class="line"></span><br><span class="line"># 存储单位</span><br><span class="line">11100101 10001101 10100010 = 24 个二进制位 = 3 个字节</span><br><span class="line">E58DA2 = 6 个十六进制位 = 3 个字节</span><br></pre></td></tr></table></figure>
<p>新建一个文件，然后往里写入汉字<code>卢</code>，保存之后退出查看文件大小，执行命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建文件</span><br><span class="line">touch test</span><br><span class="line"></span><br><span class="line"># 用 vscode 打开并写入汉字「卢」</span><br><span class="line">code test</span><br><span class="line"></span><br><span class="line"># 查看文件大小</span><br><span class="line">ls -lht</span><br><span class="line"></span><br><span class="line"># 显示文件 3B，三个字节</span><br><span class="line">-rw-r--r--   1 sebastian  staff     3B 12  6 14:14 test</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>学习 PHP 之入门概述</title>
    <url>/2019/11/03/%E5%AD%A6%E4%B9%A0-PHP-%E4%B9%8B%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0%EF%BC%88Introduction%EF%BC%89/</url>
    <content><![CDATA[<p><a name="05828867"></a></p>
<h2 id="version-iteration-版本迭代"><a class="header-anchor" href="#version-iteration-版本迭代"></a>Version Iteration（版本迭代）</h2>
<p>PHP 是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML 中，尤其适合 Web 开发。当前最新稳定版本是 PHP 7.X，相比 PHP 5.X 版本增加了不少新特性。PHP 引擎也大部分被重写，PHP 的运行速度也提到了极大的提升。PHP 5.X 现已停止维护更新，建议使用 PHP 7.X 作为开发和生产的环境。<br>
<br><br>
各个版本新特性：</p>
<ul>
<li><a href="http://php.net/manual/zh/migration72.new-features.php" target="_blank" rel="noopener">7.2</a></li>
<li><a href="http://php.net/manual/zh/migration71.new-features.php" target="_blank" rel="noopener">7.1</a></li>
<li><a href="http://php.net/manual/zh/migration70.new-features.php" target="_blank" rel="noopener">7.0</a></li>
</ul>
<p><a name="3b6a9b27"></a></p>
<h2 id="comments-split-注释与代码分离"><a class="header-anchor" href="#comments-split-注释与代码分离"></a>Comments &amp; Split（注释与代码分离）</h2>
<p>注释的代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注释方式一</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注释方式二 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注释方式三</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>代码分离的代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span>(<span class="string">"../path/file.php"</span>);</span><br><span class="line"><span class="keyword">require_once</span>(<span class="string">"../path/file.php"</span>);</span><br><span class="line"><span class="keyword">include</span>(<span class="string">"../path/file.php"</span>);</span><br><span class="line"><span class="keyword">include_once</span>(<span class="string">"../path/file.php"</span>);</span><br></pre></td></tr></table></figure>
<p><code>require()</code>、<code>require_once()</code>、<code>include()</code>、<code>include_once()</code> 的异同：</p>
<ul>
<li>运行时
<ul>
<li><code>require()</code> 和 <code>require_once()</code>、<code>include()</code> 和 <code>include_once()</code> 的区别是带 <code>once</code> 后缀的会判断在这个文件之前是否已经加载过了文件，避免重复加载。</li>
<li><code>require()</code> 和 <code>require_once()</code> 加载文件时，如果出错，将会产生一个 <code>E_COMPILE_ERROR</code> 级别的错误，脚本将会终止运行。</li>
<li><code>include()</code> 和 <code>include_once()</code> 加载文件时，如果出错，只会产生一个 <code>E_WARNING</code> 级别的警告，脚本将会继续运行。</li>
</ul>
</li>
<li>性能上
<ul>
<li><code>include()</code>、<code>include_once()</code> 执行时，文件每次都要进行读取和评估。</li>
<li><code>require()</code>、<code>require_once()</code> 执行时，文件只处理一次。</li>
<li><code>include_once()</code>、<code>require_once()</code> 是在 <code>include()</code> 和 <code>require()</code> 的基础上进步一步封装。</li>
</ul>
</li>
<li>返回值
<ul>
<li>如果加载文件内使用 <code>return</code> 返回，那么 <code>require()</code>、<code>require_once()</code> 加载文件成功会有该文件 <code>return</code> 值的返回，失败会产生致命错误。</li>
<li>如果加载文件内使用 <code>return</code> 返回，那么 <code>include()</code>、<code>include_once()</code> 加载文件成功会有该文件 <code>return</code> 值的返回，失败会抛出一个警告并返回 <code>boolean(false)</code> 。</li>
<li>如果加载文件内没有使用 <code>return</code> 返回，那么 <code>require()</code>、<code>require_once()</code>、<code>include()</code>、<code>include_once()</code> 加载文件成功会返回 <code>int(1)</code> ，失败分别会产生致命错误和抛出警告并返回 <code>boolean(false)</code>。</li>
</ul>
</li>
</ul>
<br>
代码分离相关函数如下：
<p>SPL 是 Standard PHP Library (标准 PHP 库)的缩写。它是 PHP5 引入的一个扩展库，其主要功能包括 autoload 机制的实现及包括各种 Iterator 接口或类。SPL Autoload 具体有几个函数：</p>
<ul>
<li>spl_autoload：__autoload 默认实现</li>
<li>spl_autoload_call：尝试所有已注册的函数来加载类</li>
<li>spl_autoload_register：注册 __autoload() 函数</li>
<li>spl_autoload_unregister：注销已注册的函数</li>
<li>spl_autoload_functions：返回所有已注册的函数</li>
<li>spl_autoload_extensions：注册并返回 spl_autoload 函数使用的默认文件扩展名</li>
</ul>
<p>PHP 代码分离相关函数就上述这些，但是实现起来已经是非常灵活了的。既可以简单地实现自动加载，也可以注册多个自定义的自动加载函数去满足不同场景下的代码分离需求。但是过于灵活也不好，会导致不同的框架有不同的方式实现代码分离和自动加载。代码分离和自动加载关键就是类名和文件的映射，为了统一代码分离和自动加载的方式，PHP 配合命名空间推出了 PSR-0 和 <a href="https://learnku.com/laravel/t/2081/psr-specification-psr-4-automatic-loading-specification" target="_blank" rel="noopener">PSR-4 自动加载规范</a>，由于 PSR-4 比 PSR-0 能够带来更加简洁的文件结构和更加灵活，目前 PSR-0 已经废弃。</p>
<p><a name="679b0402"></a></p>
<h2 id="builder-dependence-manager-构建与依赖管理"><a class="header-anchor" href="#builder-dependence-manager-构建与依赖管理"></a>Builder &amp; Dependence Manager（构建与依赖管理）</h2>
<p><a name="PEAR"></a></p>
<h3 id="pear"><a class="header-anchor" href="#pear"></a>PEAR</h3>
<p>PEAR 是一个常用的依赖包管理器。PEAR 需要扩展包有专属的结构, 开发者在开发扩展包的时候要提前考虑为 PEAR 定制, 否则后面将无法使用 PEAR。</p>
<p>PEAR 安装扩展包的时候, 是全局安装的, 意味着一旦安装了某个扩展包, 同一台服务器上的所有项目都能用上, 当然, 好处是当多个项目共同使用同一个扩展包的同一个版本, 坏处是如果你需要使用不同版本的话, 就会产生冲突。</p>
<ul>
<li><a href="https://pear.php.net/" target="_blank" rel="noopener">PHP 官方 PEAR</a></li>
<li><a href="http://laravel-china.github.io/php-the-right-way/#pear" target="_blank" rel="noopener">PHP 之道 PEAR</a></li>
</ul>
<p><a name="ceccc17c"></a></p>
<h3 id="composer-与-packagist"><a class="header-anchor" href="#composer-与-packagist"></a>Composer 与 Packagist</h3>
<p>Composer 是另一个常用的依赖包管理器。在 <code>composer.json</code>  文件中列出你项目所需的依赖包，加上一点简单的命令，Composer 将会自动帮你下载并设置你的项目依赖。Composer 有点类似于 Node.js 里的 NPM，或者 Ruby 世界里的 Bundler。</p>
<p>Packagist 是一个 Composer 官方的依赖包仓库，可以在 Packagist 上寻找想要的 PHP 依赖包。</p>
<ul>
<li><a href="https://getcomposer.org/" target="_blank" rel="noopener">Composer 官方网站</a></li>
<li><a href="http://laravel-china.github.io/php-the-right-way/#composer_and_packagist" target="_blank" rel="noopener">PHP 之道 Composer</a></li>
<li><a href="http://httpshttps://packagist.org/" target="_blank" rel="noopener">Packagist 官方网站    </a></li>
</ul>
<p><a name="7cfda144"></a></p>
<h2 id="composer-基本用法"><a class="header-anchor" href="#composer-基本用法"></a>Composer 基本用法</h2>
<ul>
<li>扩展包名称
<ul>
<li>扩展包名称由供应商和项目成名组成，例如：
<ul>
<li>monolog/monolog</li>
<li>laravel/laravel</li>
</ul>
</li>
</ul>
</li>
<li>扩展包版本
<ul>
<li>确切的版本号</li>
<li>范围
<ul>
<li>比较操作符 <code>&gt;、&gt;=、&lt;、&lt;=、!=</code>
<ul>
<li>
<blockquote>
<p>1.0</p>
</blockquote>
</li>
<li>
<blockquote>
<p>=1.0 &lt;=2.0</p>
</blockquote>
</li>
</ul>
</li>
<li>连字符 -
<ul>
<li>1.0 - 2.0</li>
</ul>
</li>
</ul>
</li>
<li>通配符 <code>*</code>
<ul>
<li>1.0.*</li>
</ul>
</li>
<li>赋值运算符
<ul>
<li>波浪号 ~
<ul>
<li>~1.2 相当于 &gt;=1.2 &lt;2.0.0</li>
<li>~1.2.3 相当于 &gt;=1.2.3 &lt;1.3.0</li>
</ul>
</li>
<li>折音号 ^
<ul>
<li>^1.2.3 相当于 &gt;=1.2.3 &lt;2.0.0</li>
<li>^0.3.0 相当于 &gt;=0.3.0 &lt;0.4.0</li>
</ul>
</li>
</ul>
</li>
<li>版本稳定性
<ul>
<li>如果没有显式的指定版本的稳定性，Composer 会根据使用的操作符，默认在内部指定为 -dev 或者 -stable。</li>
<li>可用的稳定性标识
<ul>
<li>dev</li>
<li>alpha</li>
<li>beta</li>
<li>RC</li>
<li>stable</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>扩展包定义
<ul>
<li>只要有一个 composer.json 文件在目录中，那么整个目录就是一个包。当添加一个扩展包被 require 到项目时，就是创建了一个依赖于其他扩展包、没有名字的包。</li>
<li>Composer 将那些已经安装在系统上，但并不是由 Composer 安装的包视为一个虚拟的平台软件包。这包括 PHP 本身、PHP 扩展和一些系统库。</li>
</ul>
</li>
<li>扩展包常见命令
<ul>
<li>composer create-project - 创建项目
<ul>
<li><code>composer create-project --prefer-dist vendor/package demo</code></li>
</ul>
</li>
<li>composer install - 安装项目所有扩展包</li>
<li>composer require - 安装一个新的扩展包
<ul>
<li><code>composer require vendor/package</code></li>
<li><code>composer require vendor/package:2.*</code></li>
<li><code>composer require vendor/package:dev-master -vvv</code></li>
<li><code>composer require vendeor/package:^2.0.0-alpha2</code></li>
</ul>
</li>
<li>composer update - 更新扩展包
<ul>
<li><code>composer update</code></li>
<li><code>composer update vendor/package</code></li>
<li><code>composer update vendor/*</code> - 支持通配符</li>
<li>需要注意的是，能升级的版本收到版本约束的影响，扩展包不会升级到超出版本约束的范围。</li>
</ul>
</li>
<li>composer remove - 移除扩展包
<ul>
<li><code>composer remove vendor/package</code></li>
</ul>
</li>
<li>composer dump - 打印自动加载索引</li>
<li>composer search - 搜索扩展包信息
<ul>
<li><code>composer search monolog</code></li>
</ul>
</li>
<li>composer show - 展示扩展包信息
<ul>
<li><code>composer serach monolog</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="388c5d85"></a></p>
<h2 id="composer-文件"><a class="header-anchor" href="#composer-文件"></a>Composer 文件</h2>
<p><a name="2e4006c4"></a></p>
<h3 id="composer-json-文件"><a class="header-anchor" href="#composer-json-文件"></a>composer.json 文件</h3>
<p>根据实际项目的 <code>composer.json</code> 文件解释其中字段，下面以 Laravel 项目的 <code>composer.json</code> 文件为例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"laravel/laravel"</span>,</span><br><span class="line">    <span class="attr">"description"</span>: <span class="string">"The Laravel Framework."</span>,</span><br><span class="line">    <span class="attr">"keywords"</span>: [<span class="string">"framework"</span>, <span class="string">"laravel"</span>],</span><br><span class="line">    <span class="attr">"license"</span>: <span class="string">"MIT"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"project"</span>,</span><br><span class="line">    <span class="attr">"require"</span>: &#123;</span><br><span class="line">        <span class="attr">"php"</span>: <span class="string">"^7.1.3"</span>,</span><br><span class="line">        <span class="attr">"fideloper/proxy"</span>: <span class="string">"^4.0"</span>,</span><br><span class="line">        <span class="attr">"guzzlehttp/guzzle"</span>: <span class="string">"~6.0"</span>,</span><br><span class="line">        <span class="attr">"laravel/framework"</span>: <span class="string">"5.7.*"</span>,</span><br><span class="line">        <span class="attr">"laravel/horizon"</span>: <span class="string">"^2.0"</span>,</span><br><span class="line">        <span class="attr">"laravel/tinker"</span>: <span class="string">"^1.0"</span>,</span><br><span class="line">        <span class="attr">"predis/predis"</span>: <span class="string">"^1.1"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"require-dev"</span>: &#123;</span><br><span class="line">        <span class="attr">"beyondcode/laravel-dump-server"</span>: <span class="string">"^1.0"</span>,</span><br><span class="line">        <span class="attr">"filp/whoops"</span>: <span class="string">"^2.0"</span>,</span><br><span class="line">        <span class="attr">"fzaninotto/faker"</span>: <span class="string">"^1.4"</span>,</span><br><span class="line">        <span class="attr">"mockery/mockery"</span>: <span class="string">"^1.0"</span>,</span><br><span class="line">        <span class="attr">"nunomaduro/collision"</span>: <span class="string">"^2.0"</span>,</span><br><span class="line">        <span class="attr">"orangehill/iseed"</span>: <span class="string">"^2.6"</span>,</span><br><span class="line">        <span class="attr">"phpunit/phpunit"</span>: <span class="string">"^7.0"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"autoload"</span>: &#123;</span><br><span class="line">        <span class="attr">"classmap"</span>: [</span><br><span class="line">            <span class="string">"database/seeds"</span>,</span><br><span class="line">            <span class="string">"database/factories"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"psr-4"</span>: &#123;</span><br><span class="line">            <span class="attr">"App\\"</span>: <span class="string">"app/"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"autoload-dev"</span>: &#123;</span><br><span class="line">        <span class="attr">"psr-4"</span>: &#123;</span><br><span class="line">            <span class="attr">"Tests\\"</span>: <span class="string">"tests/"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"extra"</span>: &#123;</span><br><span class="line">        <span class="attr">"laravel"</span>: &#123;</span><br><span class="line">            <span class="attr">"dont-discover"</span>: [</span><br><span class="line">              <span class="string">"beyondcode/laravel-dump-server"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">        <span class="attr">"post-root-package-install"</span>: [</span><br><span class="line">            <span class="string">"@php -r \"file_exists('.env') || copy('.env.example', '.env');\""</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"post-create-project-cmd"</span>: [</span><br><span class="line">            <span class="string">"@php artisan key:generate"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"post-autoload-dump"</span>: [</span><br><span class="line">            <span class="string">"Illuminate\\Foundation\\ComposerScripts::postAutoloadDump"</span>,</span><br><span class="line">            <span class="string">"@php artisan package:discover"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"config"</span>: &#123;</span><br><span class="line">        <span class="attr">"preferred-install"</span>: <span class="string">"dist"</span>,</span><br><span class="line">        <span class="attr">"sort-packages"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"optimize-autoloader"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"minimum-stability"</span>: <span class="string">"dev"</span>,</span><br><span class="line">    <span class="attr">"prefer-stable"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>name - 包名</li>
<li>description - 简介</li>
<li>keywords - 关键词</li>
<li>license - 许可协议</li>
<li>type - 安装类型
<ul>
<li>library</li>
<li>project</li>
<li>metapackage</li>
<li>composer-plugin</li>
</ul>
</li>
<li>require - 必须的软件包列表，除非这些依赖被满足，否则不会完成安装</li>
<li>require-dev - 开发或测试等目的，额外列出的依赖</li>
<li>autoload - 用于生产或部署的 PHP 自动加载映射
<ul>
<li>psr-4</li>
<li>psr-0</li>
<li>classmap</li>
<li>files</li>
</ul>
</li>
<li>autoload-dev - 用于开发或测试的 PHP 自动加载映射
<ul>
<li>psr-4</li>
<li>psr-0</li>
<li>classmap</li>
<li>files</li>
</ul>
</li>
<li>extra - 供 scripts 使用的、任意的额外数据</li>
<li>scripts - Composer 可以在安装过程中的各个阶段挂接脚本
<ul>
<li>post-root-package-install - 在 create-project 命令期间，根包安装完成后触发</li>
<li>post-create-project-cmd - 在 create-project 命令执行后触发</li>
<li>post-autoload-dump - 在自动加载器被转储后触发，<code>install</code>、<code>update</code>、<code>dump</code> 命令后触发</li>
</ul>
</li>
</ul>
<p><a href="https://docs.phpcomposer.com/articles/scripts.html" target="_blank" rel="noopener">点击查看更多 </a><a href="https://docs.phpcomposer.com/articles/scripts.html" target="_blank" rel="noopener"><code>composer.json</code></a><a href="https://docs.phpcomposer.com/articles/scripts.html" target="_blank" rel="noopener"> 文件字段说明。</a></p>
<p><a name="3bff2fa7"></a></p>
<h3 id="composer-lock-文件"><a class="header-anchor" href="#composer-lock-文件"></a>composer.lock 文件</h3>
<p>在项目中安装扩展包后，Composer 会把安装时确切的版本号列表写入 <code>composer.lock</code> 文件。</p>
<blockquote>
<p>请提交项目中的 composer.lock、composer.json 文件到版本库中</p>
</blockquote>
<p>这是非常重要，因为 <code>install</code> 命令将会检查锁文件是否存在，如果存在，它将忽略 composer.json 文件中的定义，直接下载指定的版本。这意味着，任何人简历项目都将下载与指定版本完全相同的依赖。持续集成服务器、生产环境、团队中的其他开发人员、每件事、每个人都使用相同的依赖，从而减轻潜在的错误对部署造成影响。</p>
<p><a name="15b0c584"></a></p>
<h2 id="composer-自动加载机制"><a class="header-anchor" href="#composer-自动加载机制"></a>Composer 自动加载机制</h2>
<p>Composer 将解决如下问题：</p>
<ul>
<li>有一个项目依赖于若干个扩展包</li>
<li>其中一些库依赖于若干个扩展包</li>
<li>声明项目所依赖的东西（文件，扩展包）</li>
<li>找出项目所依赖的扩展包，并安装合适的版本</li>
</ul>
<p>Composer 准备了一个自动加载文件，它可以加载 Composer 下载的所有的类文件。使用它，只需要将下面这行代码添加到项目的引导文件中即可：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="string">'vendor/autoload.php'</span>;</span><br></pre></td></tr></table></figure>
<p>以 Laravel 框架为例，在查看文件 <code>public/index.php</code> 时，可以看到代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Laravel - A PHP Framework For Web Artisans</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span>  Laravel</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>   Taylor Otwell &lt;taylor<span class="doctag">@laravel</span>.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">define(<span class="string">'LARAVEL_START'</span>, microtime(<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">|--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">| Register The Auto Loader</span></span><br><span class="line"><span class="comment">|--------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">| Composer provides a convenient, automatically generated class loader for</span></span><br><span class="line"><span class="comment">| our application. We just need to utilize it! We'll simply require it</span></span><br><span class="line"><span class="comment">| into the script here so that we don't have to worry about manual</span></span><br><span class="line"><span class="comment">| loading any of our classes later on. It feels great to relax.</span></span><br><span class="line"><span class="comment">|</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span> <span class="keyword">__DIR__</span>.<span class="string">'/../vendor/autoload.php'</span>;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>代码 <code>require __DIR__.'/../vendor/autoload.php';</code> 注册 Composer 自动加载机制，查看文件 <code>autoload.php</code> 代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// autoload.php @generated by Composer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">'/composer/autoload_real.php'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ComposerAutoloaderInit814a92544ccdda06795b3f7f5a08b060::getLoader();</span><br></pre></td></tr></table></figure>
<p><code>autoload.php</code> 文件是一个入口文件，关于 Composer 自动加载机制，需要查看 <code>autoload_real.php</code> 文件，打开文件代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// autoload_real.php @generated by Composer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComposerAutoloaderInit814a92544ccdda06795b3f7f5a08b060</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $loader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">loadClassLoader</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'Composer\Autoload\ClassLoader'</span> === $class) &#123;</span><br><span class="line">            <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/ClassLoader.php'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> !== <span class="keyword">self</span>::$loader) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>::$loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spl_autoload_register(<span class="keyword">array</span>(<span class="string">'ComposerAutoloaderInit814a92544ccdda06795b3f7f5a08b060'</span>, <span class="string">'loadClassLoader'</span>), <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">self</span>::$loader = $loader = <span class="keyword">new</span> \Composer\Autoload\ClassLoader();</span><br><span class="line">        spl_autoload_unregister(<span class="keyword">array</span>(<span class="string">'ComposerAutoloaderInit814a92544ccdda06795b3f7f5a08b060'</span>, <span class="string">'loadClassLoader'</span>));</span><br><span class="line"></span><br><span class="line">        $useStaticLoader = PHP_VERSION_ID &gt;= <span class="number">50600</span> &amp;&amp; !defined(<span class="string">'HHVM_VERSION'</span>) &amp;&amp; (!function_exists(<span class="string">'zend_loader_file_encoded'</span>) || !zend_loader_file_encoded());</span><br><span class="line">        <span class="keyword">if</span> ($useStaticLoader) &#123;</span><br><span class="line">            <span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_static.php'</span>;</span><br><span class="line"></span><br><span class="line">            call_user_func(\Composer\Autoload\ComposerStaticInit814a92544ccdda06795b3f7f5a08b060::getInitializer($loader));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_namespaces.php'</span>;</span><br><span class="line">            <span class="keyword">foreach</span> ($map <span class="keyword">as</span> $namespace =&gt; $path) &#123;</span><br><span class="line">                $loader-&gt;set($namespace, $path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_psr4.php'</span>;</span><br><span class="line">            <span class="keyword">foreach</span> ($map <span class="keyword">as</span> $namespace =&gt; $path) &#123;</span><br><span class="line">                $loader-&gt;setPsr4($namespace, $path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $classMap = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_classmap.php'</span>;</span><br><span class="line">            <span class="keyword">if</span> ($classMap) &#123;</span><br><span class="line">                $loader-&gt;addClassMap($classMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $loader-&gt;register(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ($useStaticLoader) &#123;</span><br><span class="line">            $includeFiles = Composer\Autoload\ComposerStaticInit814a92544ccdda06795b3f7f5a08b060::$files;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $includeFiles = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_files.php'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> ($includeFiles <span class="keyword">as</span> $fileIdentifier =&gt; $file) &#123;</span><br><span class="line">            composerRequire814a92544ccdda06795b3f7f5a08b060($fileIdentifier, $file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $loader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">composerRequire814a92544ccdda06795b3f7f5a08b060</span><span class="params">($fileIdentifier, $file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($GLOBALS[<span class="string">'__composer_autoload_files'</span>][$fileIdentifier])) &#123;</span><br><span class="line">        <span class="keyword">require</span> $file;</span><br><span class="line"></span><br><span class="line">        $GLOBALS[<span class="string">'__composer_autoload_files'</span>][$fileIdentifier] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中的 <code>$loader</code> 是 composer/ClassLoader.php 的 ClassLoader 类的实例。ClassLoader 类和 spl_autoload_register、spl_autoload_unregister 都是实现自动加载机制的。我们先重点关注代码中的几处 required 语句：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">$map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_namespaces.php'</span>;</span><br><span class="line">$map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_psr4.php'</span>;</span><br><span class="line">$classMap = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_classmap.php'</span>;</span><br><span class="line">$includeFiles = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_files.php'</span>;</span><br></pre></td></tr></table></figure>
<p>每个 require 语句都加载了 vendor/composer 下的一个 PHP 文件，它们分别对应不同的加载方式，在 <code>composer.json</code> 文件中它们分别被命名为：</p>
<ul>
<li>psr-4 - autoload_psr4.php
<ul>
<li><a href="https://learnku.com/laravel/t/2081/psr-specification-psr-4-automatic-loading-specification" target="_blank" rel="noopener">自动加载规范</a></li>
</ul>
</li>
<li>psr-0 - autolod_namespaces.php
<ul>
<li>自动加载规范（已废弃）</li>
</ul>
</li>
<li>classmap - autoload_classmap.php
<ul>
<li>通过配置指定的目录或文件，在 Composer 安装或更新时生成新的映射</li>
</ul>
</li>
<li>files - autoload_files.php
<ul>
<li>手动指定直接加载的文件</li>
</ul>
</li>
</ul>
<p>以 Laravel 的 <code>composer.json</code> 文件为例：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">  "autoload": &#123;</span><br><span class="line">    "psr-4": &#123;</span><br><span class="line">      "App\\": "app/"</span><br><span class="line">    &#125;,</span><br><span class="line">    "classmap": [</span><br><span class="line">      "database/seeds",</span><br><span class="line">      <span class="string">"database/factories"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着再重点分析 <code>autoload_real.php</code> 代码</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// autoload_real.php @generated by Composer</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComposerAutoloaderInit87df794bebfc20f9e9133106778dd77b</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> $loader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">loadClassLoader</span><span class="params">($class)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">'Composer\Autoload\ClassLoader'</span> === $class) &#123;</span><br><span class="line">            <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/ClassLoader.php'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">getLoader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      	<span class="comment">// 单例模式，判断 loader 是否存在</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> !== <span class="keyword">self</span>::$loader) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>::$loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 使用 spl_autoload_register 注册自动加载函数</span></span><br><span class="line">        spl_autoload_register(<span class="keyword">array</span>(<span class="string">'ComposerAutoloaderInit87df794bebfc20f9e9133106778dd77b'</span>, <span class="string">'loadClassLoader'</span>), <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 执行 new \Composer\Autoload\ClassLoader(); 时，会调用当前类的 loadClassLoader 类方法，返回 ClassLoader 类的实例</span></span><br><span class="line">        <span class="keyword">self</span>::$loader = $loader = <span class="keyword">new</span> \Composer\Autoload\ClassLoader();</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 注销刚才注册的自动加载函数</span></span><br><span class="line">        spl_autoload_unregister(<span class="keyword">array</span>(<span class="string">'ComposerAutoloaderInit87df794bebfc20f9e9133106778dd77b'</span>, <span class="string">'loadClassLoader'</span>));</span><br><span class="line"></span><br><span class="line">      	<span class="comment">// 当 PHP 版本大于 5.6、没有使用 HHVM_VERSION、没有使用 Zend Guard 编码，则执行下面代码</span></span><br><span class="line">        $useStaticLoader = PHP_VERSION_ID &gt;= <span class="number">50600</span> &amp;&amp; !defined(<span class="string">'HHVM_VERSION'</span>) &amp;&amp; (!function_exists(<span class="string">'zend_loader_file_encoded'</span>) || !zend_loader_file_encoded());</span><br><span class="line">        <span class="keyword">if</span> ($useStaticLoader) &#123;</span><br><span class="line">            <span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_static.php'</span>;</span><br><span class="line">          </span><br><span class="line">						<span class="comment">// 使用静态映射的方式去获取所有 PSR-4、PSR-0、ClassMap、files 等加载方式的类名和文件</span></span><br><span class="line">            call_user_func(\Composer\Autoload\ComposerStaticInit87df794bebfc20f9e9133106778dd77b::getInitializer($loader));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 PSR-0 加载方式的类和路径</span></span><br><span class="line">            $map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_namespaces.php'</span>;</span><br><span class="line">            <span class="keyword">foreach</span> ($map <span class="keyword">as</span> $namespace =&gt; $path) &#123;</span><br><span class="line">                $loader-&gt;set($namespace, $path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          	<span class="comment">// 获取 PSR-4 加载方式的类和路径</span></span><br><span class="line">            $map = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_psr4.php'</span>;</span><br><span class="line">            <span class="keyword">foreach</span> ($map <span class="keyword">as</span> $namespace =&gt; $path) &#123;</span><br><span class="line">                $loader-&gt;setPsr4($namespace, $path);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">	          <span class="comment">// 获取 classmap 加载方式的类和路径</span></span><br><span class="line">            $classMap = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_classmap.php'</span>;</span><br><span class="line">            <span class="keyword">if</span> ($classMap) &#123;</span><br><span class="line">                $loader-&gt;addClassMap($classMap);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        <span class="comment">// ClassLoader 注册自动加载函数</span></span><br><span class="line">        $loader-&gt;register(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接 require 所有 files 加载方式的文件</span></span><br><span class="line">        <span class="keyword">if</span> ($useStaticLoader) &#123;</span><br><span class="line">            $includeFiles = Composer\Autoload\ComposerStaticInit87df794bebfc20f9e9133106778dd77b::$files;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $includeFiles = <span class="keyword">require</span> <span class="keyword">__DIR__</span> . <span class="string">'/autoload_files.php'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">foreach</span> ($includeFiles <span class="keyword">as</span> $fileIdentifier =&gt; $file) &#123;</span><br><span class="line">            composerRequire87df794bebfc20f9e9133106778dd77b($fileIdentifier, $file);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> $loader;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">composerRequire87df794bebfc20f9e9133106778dd77b</span><span class="params">($fileIdentifier, $file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>($GLOBALS[<span class="string">'__composer_autoload_files'</span>][$fileIdentifier])) &#123;</span><br><span class="line">        <span class="keyword">require</span> $file;</span><br><span class="line"></span><br><span class="line">        $GLOBALS[<span class="string">'__composer_autoload_files'</span>][$fileIdentifier] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，Composer 自动加载机制已经基本了解，如果想知道 $loader 是如何实现加载对应文件的，可以了解 ClassLoader 类的 loadClass 类方法的实现，在此就不在赘述了。</p>
]]></content>
      <tags>
        <tag>PHP Composer</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Elasticsearch + Kibana + Logstash 搭建简单日志分析平台</title>
    <url>/2019/10/29/%E4%BD%BF%E7%94%A8-Elasticsearch-Kibana-Logstash-%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h2 id="elk-架构图"><a class="header-anchor" href="#elk-架构图"></a>ELK 架构图</h2>
<h2 id="elk-流程图"><a class="header-anchor" href="#elk-流程图"></a>ELK 流程图</h2>
<h2 id="安装-elasticsearch"><a class="header-anchor" href="#安装-elasticsearch"></a>安装 Elasticsearch</h2>
<p>导入公钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<p>安装 Elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apt-transport-https</span><br><span class="line"></span><br><span class="line">echo &quot;deb http://mirrors.tencentyun.com/elasticstack/apt/7.x/ stable main&quot; | sudo tee -a /etc/apt/sources.list.d/elastic-7.x.list</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line">sudo apt-get install elasticsearch</span><br></pre></td></tr></table></figure>
<p>配置 Elasticsearch 开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo /bin/systemctl daemon-reload</span><br><span class="line">sudo /bin/systemctl enable elasticsearch.service</span><br></pre></td></tr></table></figure>
<p>操作 Elasticsearch 常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start elasticsearch.service</span><br><span class="line">sudo systemctl stop elasticsearch.service</span><br><span class="line">sudo systemctl restart elasticsearch.service</span><br></pre></td></tr></table></figure>
<h2 id="安装-kibana"><a class="header-anchor" href="#安装-kibana"></a>安装 Kibana</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install kibana</span><br></pre></td></tr></table></figure>
<h2 id="安装-logstash"><a class="header-anchor" href="#安装-logstash"></a>安装 Logstash</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="安装-redis"><a class="header-anchor" href="#安装-redis"></a>安装 Redis</h2>
]]></content>
      <tags>
        <tag>ELK Elasticsearch Kibana Logstash</tag>
      </tags>
  </entry>
  <entry>
    <title>学习 PHP 之前言</title>
    <url>/2019/10/28/%E5%AD%A6%E4%B9%A0-PHP-%E4%B9%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>  时光荏苒，现在已是 2019 年了，离我大学毕业已经足有五周年。回望这五年的编程职业生涯，由于自身并非科班出身，加上工作始于三线城市，所以这一路走来也是磕磕碰碰，碰壁不少。其中曾跟风过方向转型，后因项目破产而转型失败，也曾跌入盲目追求高并发、高性能的知识陷阱，殊不知非立足于项目的知识经验，皆是空中阁楼，转眼间就忘得一干二净。也存在过没有自己主见，不断被媒体灌输知识焦虑而不断购买课程的一段时间。回顾这些经历，虽然让我时常感觉到懊悔，但毕竟也是吃一堑，长一智，这会让我不断调整方向，最终选择正确的学习成长道路。</p>
<br>
<p>  这个系列的文章源于我看到一张编程学习体系图片，这张图片引起了我的注意与反思。我突然之间发现，我未曾系统地去学习过一门编程语言。我的专业是电子商务，编程完全是自学出来，大学毕业到目前为止，所有的知识来源皆是项目驱动、工资驱动和道听途说。例如项目需要这门技术，我便学习这门技术；招聘要求必须掌握哪门技术，我便学习哪门技术；社区大牛说学什么框架，我便跟风学习什么框架。对于编程到底是什么，编程是否存在通用的学习模型，编程的体系如何划分，我未曾深入思考。我知道有数据结构、算法、面向对象、网络编程、编码规范等等，等等；但是它们属于编程系统的哪一块，它们之间的关系是什么，如何将它们这些独立的知识节点关联起来，每门编程语言细分下去又有何不同，有何相同，它们之间特性是什么。这些问题，我都没有答案。</p>
<br>
<p><img src="https://sebastian-1256190695.cos.ap-guangzhou.myqcloud.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E9%80%9A%E7%94%A8%E5%AD%A6%E4%B9%A0%E4%BD%93%E7%B3%BB.jpg" alt="编程语言通用学习框架"></p>
<p>  为了得到答案，我决定根据图片内容去重新学习一遍 PHP，然后从 PHP 扩展到其他编程语言，最终达到不再局限于某门编程语言的能力界限。</p>
]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World!</title>
    <url>/2019/10/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="quick-start"><a class="header-anchor" href="#quick-start"></a>Quick Start</h2>
<h3 id="create-a-new-post"><a class="header-anchor" href="#create-a-new-post"></a>Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="run-server"><a class="header-anchor" href="#run-server"></a>Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="generate-static-files"><a class="header-anchor" href="#generate-static-files"></a>Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="deploy-to-remote-sites"><a class="header-anchor" href="#deploy-to-remote-sites"></a>Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
