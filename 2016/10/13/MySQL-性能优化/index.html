<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>MySQL 性能优化 | “人类的悲欢并不相通，我只觉得他们吵闹。”</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="七月十五九月初七">
  <meta name="keywords" content="Sebastian Kennedy Blog PHP Laravel Yii">
  <meta name="description" content="Sebastian Kennedy Blog PHP Laravel Yii">
  <script id="hexo-configurations">
  var CONFIG = {
    root: '/',
    theme: 'lx',
    version: '1.4.5',
    localsearch:{
      "enable": true,
      "trigger": "auto",
      "top_n_per_article": 1,
      "unescape": false,
      "preload": false
      },
    path: 'search.xml'
  };
</script>

  <link rel="shortcut icon" href="https://sebastian-1256190695.cos.ap-guangzhou.myqcloud.com/person_1.jpg">
  <link rel="stylesheet" href="/css/main.css">
  <script src="/js/jquery.min.js"></script>
  <script src="/js/jquery.jside.menu.js"></script>
	<script>
	$(document).ready(function(){
	$(".menu-container").jSideMenu({
	    jSidePosition: "position-right",
	    jSideSticky: true,
	    jSideSkin: "black-grey",
	     });
	}); 
	</script>
  <!--Google_Analytics-->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-150354789-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-150354789-1');
</script>

  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat:300|Noto+Serif+SC&amp;display=swap">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
</head>
<body>
<div class="single">
<div id="page">
<div id="lx-aside" style="background-image: url(https://sebastian-1256190695.cos.ap-guangzhou.myqcloud.com/page-cover.jpg)" data-stellar-background-ratio="0.5">
  <div class="overlay">
  <div class="page-title">
    <div class="avatar"><a href="/"><img src="https://sebastian-1256190695.cos.ap-guangzhou.myqcloud.com/person_1.jpg"></a></div>
    <span>2016-10-13</span>
    <h2>MySQL 性能优化</h2>
    <div class="tags"><i class="fa fa-tag"></i><a class="tag-link" href="/tags/MySQL/">MySQL</a></div>
    </div>
</div>
</div>
<div id="lx-main-content">
  <div class="lx-post">
    <div class="lx-entry padding">
      <div>
        <h2 id="可以进行优化的层面"><a class="header-anchor" href="#可以进行优化的层面"></a>可以进行优化的层面</h2>
<ul>
<li>硬件</li>
<li>系统配置</li>
<li>数据库表结构</li>
<li>SQL 语句和索引</li>
</ul>
<h2 id="进行优化前的数据准备"><a class="header-anchor" href="#进行优化前的数据准备"></a>进行优化前的数据准备</h2>
<p>打开以下链接下载数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://downloads.mysql.com/docs/sakila-db.zip</span><br></pre></td></tr></table></figure>
<p>打开终端，执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 登录 MySQL Cli 模式</span><br><span class="line">mysql -uroot -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 创建数据库</span><br><span class="line">SOURCE /Users/LuisEdware/Downloads/sakila-db/sakila-schema.sql.sql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 填充数据到数据库</span><br><span class="line">SOURCE /Users/LuisEdware/Downloads/sakila-db/sakila-data.sql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 使用 sakila 数据库</span><br><span class="line">USE sakila;</span><br></pre></td></tr></table></figure>
<h2 id="sql-语句和索引"><a class="header-anchor" href="#sql-语句和索引"></a>SQL 语句和索引</h2>
<h3 id="mysql-慢查询日志"><a class="header-anchor" href="#mysql-慢查询日志"></a>MySQL 慢查询日志</h3>
<p>如何发现有问题的 SQL？答案是使用 MySQL 慢查询日志对有效率问题的 SQL 进行监控，执行命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 查看是否开启慢查询日志</span><br><span class="line">show variables like "slow_query_log";</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看是否设置了把没有索引的记录到慢查询日志</span><br><span class="line">show variables like "log_queries_not_using_indexes";</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看是否设置慢查询的 SQL 执行时间</span><br><span class="line">show variables like "long_query_time";</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看慢查询日志记录位置</span><br><span class="line">show variables like "slow_query_log_file";</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 开启慢查询日志</span><br><span class="line">set global slow_query_log=on</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置没有索引的记录到慢查询日志</span><br><span class="line">set global log_queries_not_using_indexes=on</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 设置到慢查询日志的 SQL 执行时间</span><br><span class="line">set global long_query_time=0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 查看慢查询日志（在 Linux 终端下执行）</span><br><span class="line">tail -50 /usr/local/var/mysql/luyiyuandeMacBook-Pro-slow.log;</span><br></pre></td></tr></table></figure>
<p>慢查询日志所包含的内容</p>
<ul>
<li>SQL 的执行时间：<strong># Time: 2016-10-13T10:01:45.914267Z</strong></li>
<li>SQL 的执行主机：<strong># User@Host: root[root] @ localhost []  Id:   949</strong></li>
<li>SQL 的执行信息：<strong># Query_time: 0.000227  Lock_time: 0.000099 Rows_sent: 2  Rows_examined: 2</strong></li>
<li>SQL 的执行时间：<strong>SET timestamp=1476352905;</strong></li>
<li>SQL 的执行内容：<strong>select * from store;</strong></li>
</ul>
<p>慢查询日志分析工具</p>
<ul>
<li>mysqldumpslow
<ul>
<li>安装：MySQL 数据库自带</li>
<li>使用：<code>mysqldumpslow /usr/local/var/mysql/luyiyuandeMacBook-Pro-slow.log;</code></li>
<li>选项</li>
<li>参数</li>
</ul>
</li>
<li>pt-query-digest
<ul>
<li>安装：<code>brew install brew install percona-toolkit</code></li>
<li>使用：<code>pt-query-digest /usr/local/var/mysql/luyiyuandeMacBook-Pro-slow.log | more;</code></li>
<li>选项</li>
<li>参数</li>
</ul>
</li>
</ul>
<p>如何通过慢查询日志发现有问题的 SQL？</p>
<ul>
<li>查询次数多且每次查询占用时间长的 SQL</li>
<li>IO 大的 SQL</li>
<li>未命中索引的 SQL</li>
</ul>
<h3 id="explain-分析-sql-的执行计划"><a class="header-anchor" href="#explain-分析-sql-的执行计划"></a>EXPLAIN 分析 SQL 的执行计划</h3>
<p>使用 EXPLAIN 分析 SQL 的执行计划的例子如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> staff;</span><br></pre></td></tr></table></figure>
<p>使用 EXPLAIN 分析 SQL 的各列参数含义如下：</p>
<ul>
<li>id：SQL 语句执行顺序编号</li>
<li>select_type：SQL 语句执行的类型，主要区别普通查询、联合查询和子查询之类的复杂查询</li>
<li>table：SQL 语句执行所引用的数据表</li>
<li>type：显示连接使用的类型</li>
<li>possible_keys：指出 MySQL 能在该数据表中使用哪些索引有助于查询</li>
<li>key：SQL 语句执行时所使用的索引</li>
<li>key_len：SQL 语句执行时所使用的索引的长度。在不损失精确性的情况下，长度越短越好</li>
<li>ref：显示索引的哪一列被使用了</li>
<li>rows：MySQL 认为必须检查的用来返回请求数据的行数</li>
<li>Extra：提供 MySQL 优化器一系列额外信息</li>
</ul>
<h3 id="max-和-count-的优化"><a class="header-anchor" href="#max-和-count-的优化"></a>MAX() 和 COUNT() 的优化</h3>
<h4 id="max"><a class="header-anchor" href="#max"></a>MAX()</h4>
<p>分析 SQL 语句：使用 MAX() 方法查询最后一笔交易的时间</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT MAX(payment_date) FROM payment_date</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: payment</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 16086</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<p>如果数据表的数据非常大，查询频率又非常高，那么服务器的 IO 消耗也会非常高，所以这条 SQL 语句需要优化。可以通过建立索引进行优化。执行代码如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_paydate <span class="keyword">ON</span> payment(payment_date);</span><br></pre></td></tr></table></figure>
<p>然后再分析 SQL 语句，执行结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: NULL</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: NULL</span><br><span class="line">possible_keys: NULL</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: NULL</span><br><span class="line">     filtered: NULL</span><br><span class="line">        Extra: Select tables optimized away</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>经过优化之后，由于索引是按顺序排列的，MySQL 不需要查询表中的数据，而是通过查询索引最后的一个数据，就可以得知执行结果了。而且这个时候，不管表的数据量多大，查询 MAX() 所需要的时间都是基本固定的，这样就尽可能地减少了 IO 操作。</p>
<h4 id="count"><a class="header-anchor" href="#count"></a>COUNT()</h4>
<p>分析 SQL 语句：使用 COUNT() 函数在一条 SQL 中同时查出 2006 年和 2007 年电影的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	count(release_year = &apos;2006&apos; OR NULL) AS &apos;2006 年电影数量&apos; ,</span><br><span class="line">	count(release_year = &apos;2007&apos; OR NULL) AS &apos;2007 年电影数量&apos;</span><br><span class="line">FROM</span><br><span class="line">	film;</span><br></pre></td></tr></table></figure>
<p>count(*) 包含空值，count(id) 不包含空值。上述语句就是优化 Count() 函数取值</p>
<h3 id="子查询"><a class="header-anchor" href="#子查询"></a>子查询</h3>
<p>分析 SQL 语句：查询 sandra 出演的所有影片</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">	title ,</span><br><span class="line">	release_year ,</span><br><span class="line">	<span class="keyword">LENGTH</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	film</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	film_id <span class="keyword">IN</span>(</span><br><span class="line">		<span class="keyword">SELECT</span></span><br><span class="line">			film_id</span><br><span class="line">		<span class="keyword">FROM</span></span><br><span class="line">			film_actor</span><br><span class="line">		<span class="keyword">WHERE</span></span><br><span class="line">			actor_id <span class="keyword">IN</span>(</span><br><span class="line">				<span class="keyword">SELECT</span></span><br><span class="line">					actor_id</span><br><span class="line">				<span class="keyword">FROM</span></span><br><span class="line">					actor</span><br><span class="line">				<span class="keyword">WHERE</span></span><br><span class="line">					first_name = <span class="string">'sandra'</span></span><br><span class="line">			)</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p>通常情况下，需要把子查询优化为 join 查询，但在优化时要注意关联键是否有一对多的关系，要注意重复数据。</p>
<h3 id="group-by"><a class="header-anchor" href="#group-by"></a>GROUP BY</h3>
<p>group by 可能会出现临时表、文件排序等，影响效率。可以通过关联的子查询，来避免产生临时表和文件排序，可以节省 IO。</p>
<p>group by 查询优化前：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span></span><br><span class="line">	actor.first_name ,</span><br><span class="line">	actor.last_name ,</span><br><span class="line">	<span class="keyword">Count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">	sakila.film_actor</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sakila.actor <span class="keyword">USING</span>(actor_id)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">	film_actor.actor_id;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: actor</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 200</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using temporary; Using filesort</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: film_actor</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: PRIMARY,idx_fk_film_id</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 2</span><br><span class="line">          ref: sakila.actor.actor_id</span><br><span class="line">         rows: 27</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>group by 查询优化后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT</span><br><span class="line">	actor.first_name ,</span><br><span class="line">	actor.last_name ,</span><br><span class="line">	c.cnt</span><br><span class="line">FROM</span><br><span class="line">	sakila.actor</span><br><span class="line">INNER JOIN(</span><br><span class="line">	SELECT</span><br><span class="line">		actor_id ,</span><br><span class="line">		count(*) AS cnt</span><br><span class="line">	FROM</span><br><span class="line">		sakila.film_actor</span><br><span class="line">	GROUP BY</span><br><span class="line">		actor_id</span><br><span class="line">) AS c USING(actor_id);</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: PRIMARY</span><br><span class="line">        table: actor</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ALL</span><br><span class="line">possible_keys: PRIMARY</span><br><span class="line">          key: NULL</span><br><span class="line">      key_len: NULL</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 200</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 2. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: PRIMARY</span><br><span class="line">        table: &lt;derived2&gt;</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: &lt;auto_key0&gt;</span><br><span class="line">          key: &lt;auto_key0&gt;</span><br><span class="line">      key_len: 2</span><br><span class="line">          ref: sakila.actor.actor_id</span><br><span class="line">         rows: 27</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">*************************** 3. row ***************************</span><br><span class="line">           id: 2</span><br><span class="line">  select_type: DERIVED</span><br><span class="line">        table: film_actor</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: index</span><br><span class="line">possible_keys: PRIMARY,idx_fk_film_id</span><br><span class="line">          key: PRIMARY</span><br><span class="line">      key_len: 4</span><br><span class="line">          ref: NULL</span><br><span class="line">         rows: 5462</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: Using index</span><br><span class="line">3 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>
<h3 id="limit"><a class="header-anchor" href="#limit"></a>LIMIT</h3>
<p>LIMIT 常用于分页处理，时常会伴随 ORDER BY 从句使用，因此大多时候会使用 Filesorts ，这样会造成大量的 IO 问题</p>
<p>优化步骤1：使用有索引的列或主键进行 Order By 操作<br>
优化步骤2：记录上次返回的主键，在下次查询时使用主键过滤（保证主键是自增且有索引）</p>
<h3 id="索引优化"><a class="header-anchor" href="#索引优化"></a>索引优化</h3>
<h4 id="1-为合适的列建立索引"><a class="header-anchor" href="#1-为合适的列建立索引"></a>1.为合适的列建立索引</h4>
<ul>
<li>在 where 从句，group by 从句，order by 从句，on 从句中出现的列</li>
<li>索引字段越小越好</li>
<li>离散度的列放到联合索引的前面</li>
</ul>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;</span><br></pre></td></tr></table></figure>
<p>上述 SQL 语句，是 <code>index(staff_id,customer_id)</code> 合理，还是 <code>index(customer_id,staff_id)</code> 合理。执行语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT customer_id) , count(DISTINCT staff_id) FROM payment;</span><br><span class="line"></span><br><span class="line">-- 结果是 599	2</span><br></pre></td></tr></table></figure>
<p>由于 customer_id 的离散度更大，所以应该使用 <code>index(customer_id,staff_id)</code></p>
<h4 id="2-找到重复和冗余的索引"><a class="header-anchor" href="#2-找到重复和冗余的索引"></a>2.找到重复和冗余的索引</h4>
<p>之所以要找到重复和冗余的索引，是因为过多的索引不但影响写入，而且影响查询，索引越多，分析越慢。那么为何重复索引、冗余索引？概念如下：</p>
<p>重复索引是指相同的列以相同的顺序建立的同类型的索引，如下表中 primary key 和 ID 列上的索引就是重复索引，例子如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">	<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">	title <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">	<span class="keyword">UNIQUE</span>(<span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>
<p><code>UNIQUE(ID)</code> 和 <code>PRIMARY KEY</code> 重复了。</p>
<p>冗余索引是指多个索引的前缀列相同，或是在联合索引中包含了主键的索引，例子如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">test</span>(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span> ,</span><br><span class="line">	<span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">	title <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> ,</span><br><span class="line">	<span class="keyword">KEY</span>(<span class="keyword">NAME</span> , <span class="keyword">id</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span> = <span class="keyword">INNODB</span>;</span><br></pre></td></tr></table></figure>
<p>查找重复及冗余索引的 SQL 语句如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">USE information_schema;</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line">	a.TABLE_SCHEMA AS &apos;数据名&apos; ,</span><br><span class="line">	a.table_name AS &apos;表名&apos; ,</span><br><span class="line">	a.index_name AS &apos;索引1&apos; ,</span><br><span class="line">	b.INDEX_NAME AS &apos;索引2&apos; ,</span><br><span class="line">	a.COLUMN_NAME AS &apos;重复列名&apos;</span><br><span class="line">FROM</span><br><span class="line">	STATISTICS a</span><br><span class="line">JOIN STATISTICS b ON a.TABLE_SCHEMA = b.TABLE_SCHEMA</span><br><span class="line">AND a.TABLE_NAME = b.table_name</span><br><span class="line">AND a.SEQ_IN_INDEX = b.SEQ_IN_INDEX</span><br><span class="line">AND a.COLUMN_NAME = b.COLUMN_NAME</span><br><span class="line">WHERE</span><br><span class="line">	a.SEQ_IN_INDEX = 1</span><br><span class="line">AND a.INDEX_NAME &lt;&gt; b.INDEX_NAME</span><br></pre></td></tr></table></figure>
<p>也可以使用工具 <code>pt-duplicate-key-checker</code> 检查重复索引和冗余索引,使用例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-duplicate-key-checker -uroot -p &apos;123456&apos; -h 127.0.0.1 -d sakila</span><br></pre></td></tr></table></figure>
<p>执行结果如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ########################################################################</span></span><br><span class="line"><span class="comment"># Summary of indexes</span></span><br><span class="line"><span class="comment"># ########################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Size Duplicate Indexes   118425374</span></span><br><span class="line"><span class="comment"># Total Duplicate Indexes  24</span></span><br><span class="line"><span class="comment"># Total Indexes            1439</span></span><br></pre></td></tr></table></figure>
<h4 id="3-删除不用的索引"><a class="header-anchor" href="#3-删除不用的索引"></a>3.删除不用的索引</h4>
<p>目前 MySQL 中还没有记录索引的使用情况，但是在 PerconMySQL 和 MariaDB 中可以通过 INDEX_STATISTICS 表来查看哪些索引未使用，但在 MySQL 中目前只能通过慢查询日志配合共组 <code>pt-index-usage</code> 来进行索引使用情况的分析。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pt-index-usage -uroot -p &apos;123456&apos; /usr/local/var/mysql/luyiyuandeMacBook-Pro-slow.log;</span><br></pre></td></tr></table></figure>
<h2 id="数据库结构优化"><a class="header-anchor" href="#数据库结构优化"></a>数据库结构优化</h2>
<h3 id="选择合适的数据类型"><a class="header-anchor" href="#选择合适的数据类型"></a>选择合适的数据类型</h3>
<ul>
<li>使用可以存下你的数据的最小的数据类型</li>
<li>使用简单的数据类型。Integer 要比 varchar 类型在 MySQL 中处理更高效</li>
<li>尽可能使用 not null 定义字段</li>
<li>尽量少用 text 类型，非用不可时最好考虑分表</li>
</ul>
<h3 id="数据库表的范式化优化与反范式化优化"><a class="header-anchor" href="#数据库表的范式化优化与反范式化优化"></a>数据库表的范式化优化与反范式化优化</h3>
<p>略</p>
<h3 id="数据库表的垂直拆分"><a class="header-anchor" href="#数据库表的垂直拆分"></a>数据库表的垂直拆分</h3>
<p>垂直拆分，就是把原来一个有很多列的表拆分成多个表，这解决了表的宽度问题。通常垂直拆分就可以按以下原则进行：</p>
<ul>
<li>把不太常用的字段单独存放到一个表中</li>
<li>把大字段独立存放到一个表中</li>
<li>把经常一起使用的字段放到一起</li>
</ul>
<h3 id="数据库表的水平拆分"><a class="header-anchor" href="#数据库表的水平拆分"></a>数据库表的水平拆分</h3>
<p>当单表的数据量过大，导致增删查改等操作过慢，这时候需要对表进行水平拆分。水平拆分的表，每一张表的结构都是完全一致的。</p>
<p>常用的水平拆分方法为：</p>
<ol>
<li>对 customer_id 进行 hash 运算，如果要拆分成 5 个表则使用 mod(customer_id,5) 取出 0-4 个值</li>
<li>针对不同的 hashID 把数据存到不同的表中</li>
</ol>
<p>挑战：</p>
<ul>
<li>跨分区表进行数据查询</li>
<li>统计及后台报表操作</li>
</ul>
<h2 id="系统配置优化"><a class="header-anchor" href="#系统配置优化"></a>系统配置优化</h2>
<h3 id="数据库系统配置优化"><a class="header-anchor" href="#数据库系统配置优化"></a>数据库系统配置优化</h3>
<p>数据库是基于操作系统的，目前大多数 MySQL 都是安装在Linux 系统之上，所以对于操作系统的一些参数配置也会影响到 MySQL 的性能，下面列举一些常用到的系统配置。</p>
<p>网络方面的配置，要修改文件 <code>/etc/sysctl.conf</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 增加 tcp 支持的队列数</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 65535</span><br><span class="line"></span><br><span class="line"># 减少断开连接时，资源回收</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 8000</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 10</span><br></pre></td></tr></table></figure>
<p>打开文件数的限制，可以使用 ulimit -a 查看目录的各项限制，可以修改文件 <code>/etc/security/limits.conf</code> ，增加以下内容以修改打开文件数量的限制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">soft nofile 65535</span><br><span class="line">hard nofile 65535</span><br></pre></td></tr></table></figure>
<p>除此之外最好在 MySQL 服务器上关闭 iptables，selinux 等防火墙软件。</p>
<h3 id="mysql-配置文件"><a class="header-anchor" href="#mysql-配置文件"></a>MySQL 配置文件</h3>
<p>MySQL 可以通过启动时指定配置参数和使用配置文件两种方法进行配置，在一般情况下，配置文件位于 <code>/etc/my.cnf</code> 或是 <code>/etc/mysql/my.cnf</code>，MySQL 查询配置文件的顺序是可以通过以下方法过的</p>
<p>常用参数说明</p>
<ul>
<li>innodb_buffer_pool_size：用于配置 Innodb 的缓冲池
<ul>
<li>如果数据库中只有 Innodb 表，则推荐配置量为总内存的 75%</li>
<li>Innodb_buffer_pool_size &gt;= Total MB</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">ENGINE</span> ,</span><br><span class="line"><span class="keyword">round</span>(</span><br><span class="line">  <span class="keyword">sum</span>(data_length + index_length) / <span class="number">1024</span> / <span class="number">1024</span> ,</span><br><span class="line">  <span class="number">1</span></span><br><span class="line">) <span class="keyword">AS</span> <span class="string">'Total MB'</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">information_schema. <span class="keyword">TABLES</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">table_schema <span class="keyword">NOT</span> <span class="keyword">IN</span>(</span><br><span class="line">  <span class="string">"information_schema"</span> ,</span><br><span class="line">  <span class="string">"performance_schema"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">ENGINE</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>innodb_buffer_pool_instances</strong>：MySQL 5.5 中新增参数，可以控制缓冲池的个数，默认情况下只有一个缓冲池。</li>
<li><strong>innodb_log_buffer_size</strong>：Innodb 日志缓冲的大小，由于日志最长，每秒钟就会刷新，所以一般不用太大。</li>
<li><strong>innodb_flush_log_at_trx_commit</strong>：对 Innodb 的 IO 效率影响很大。</li>
<li><strong>innodb_file_per_table</strong>：控制 Innodb 每一个表都使用独立的表空间，默认为 OFF，也就是所有表都会建立在共享表空间中。</li>
<li><strong>innodb_stats_on_metadata</strong>：决定 MySQL 在什么情况下会刷新 innodb 表的统计信息。</li>
</ul>
<h3 id="第三方配置工具使用"><a class="header-anchor" href="#第三方配置工具使用"></a>第三方配置工具使用</h3>
<p><strong><code>percona：https://tools.percona.com/</code></strong></p>
<h2 id="服务器硬件优化"><a class="header-anchor" href="#服务器硬件优化"></a>服务器硬件优化</h2>
<ul>
<li>如何选择 CPU
<ul>
<li>MySQL 有一些工作只能使用到单核 CPU，选择高频</li>
<li>MySQL 对 CPU 核数的支持并不是越多越快，MySQL 5.5 版本不要超过 32 个核</li>
</ul>
</li>
<li>硬盘 IO 优化
<ul>
<li>RAID 级别简介
<ul>
<li>RAID 0：也称为条带，就是把多个磁盘链接成一个硬盘使用，这个级别 IO 最好</li>
<li>RAID 1：也成为镜像，要求至少两个磁盘，每组磁盘存储的数据相同</li>
<li>RAID 1 + 0：就是 RAID 1 和 RAID 0的结合。同时具备两个级别的优缺点。一般建议数据库使用这个级别。</li>
<li>RAID 5：把多个（最少 3 个）硬盘合并成 1 个逻辑盘使用，数据读写时会建立奇偶校验信息，并且奇偶校验信息和相对应的数据分别存储在不同的磁盘上。当 RAID 5 的一个磁盘数据发生损坏后，利用剩下的数据和相应的奇偶校验信息去恢复被损坏的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>

      </div>
    </div>
  </div>
</div>
<div class="lx-navigation">
	<div class="lx-cover prev lx-cover-sm" style="background-image: url(https://sebastian-1256190695.cos.ap-guangzhou.myqcloud.com/footer_2.jpg)">
		<div class="overlay"></div>
		<a class="copy" href="/2016/10/20/打造扛得住的-MySQL-数据库架构/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Next</span>
						<h3>打造扛得住的 MySQL 数据库架构</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
        <div class="lx-cover next lx-cover-sm" style="background-image: url(https://sebastian-1256190695.cos.ap-guangzhou.myqcloud.com/footer_1.jpg)">
		<div class="overlay"></div>
		<a class="copy" href="/2016/10/04/Linux-Shell-基础之条件判断语句/">
			<div class="display-t">
				<div class="display-tc">
					<div>
						<span>Prev</span>
						<h3>Linux Shell 基础之条件判断语句</h3>
					</div>
				</div>
			</div>
		</a>
	</div>
</div>
</div>
<div class="comment"><div id="comments"></div></div>
<footer>
  <div>
  Copyright &copy; 2015.<a href="/">七月十五九月初七</a>
  <br>
  <a href="http://beian.miit.gov.cn/" target="_blank">粤ICP备18047433号</a><br>
  </div>
</footer>
</div>
<a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i></a>
<div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Search..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>

<button class="menu-trigger"></button>
<div class="menu">
  <div class="menu-head">
    <span class="layer">
      <div class="col">
        <div class="row for-pic">
          <div class="profile-pic">
            <a href="/"><img src="https://sebastian-1256190695.cos.ap-guangzhou.myqcloud.com/person_1.jpg" alt="七月十五九月初七"></a>
          </div>
        </div>
        <div class="row for-name">
          <p>七月十五九月初七</p>
          <span class="tagline">人类的悲欢并不相通，我只觉得他们吵闹。</span>
        </div>
      </div>
    </span>
  </div>
  <nav class="menu-container">
  <ul class="menu-items">
    <li><a href="/"><i class="fa fa-home fa-fw"></i>首页</a></li>
    <li><a href="/archives/"><i class="fa fa-archive fa-fw"></i>归档</a></li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-bookmark fa-fw"></i>页面</span>
        <ul>
          <li><a href="/guestbook">留言</a></li>
        <li><a href="/about">关于</a></li>
        </ul>
    </li>
    <li class="has-sub"><span class="dropdown-heading">
      <i class="fa fa-link fa-fw"></i>友链</span>
        <ul>
          <li> <a href="https://lx.blleng.cn" target="_blank">Theme-Lx</a></li>
        </ul>
    </li>
  </ul>
  </nav>
</div>

<div class="gototop js-top">
  <a href="#" class="js-gotop"><i class="fa fa-arrow-up"></i></a>
</div>
<script src="/js/jquery.easing.min.js"></script>
<script src="/js/jquery.waypoints.min.js"></script>
<script src="/js/jquery.stellar.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/local.search.js"></script>


</body>
</html>
